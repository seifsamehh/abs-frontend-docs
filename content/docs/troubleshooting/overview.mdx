---
title: Problems & Solutions
description: Common frontend challenges and their proven solutions
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# ðŸ”§ Problems & Solutions

<Callout type="info">
  This section documents common frontend problems we encounter and their proven
  solutions. Learn from our experience to avoid common pitfalls.
</Callout>

## Performance Issues

### Problem: Slow Page Load Times

**Symptoms:**

- High First Contentful Paint (FCP) times
- Poor Lighthouse scores
- User complaints about slow loading

**Root Causes:**

- Large JavaScript bundles
- Unoptimized images
- Blocking render resources
- Inefficient API calls

**Solutions:**

<Tabs items={['Code Splitting', 'Image Optimization', 'Bundle Analysis']}>
  <Tab value="Code Splitting">
    ```typescript
    // Use dynamic imports for code splitting
    import dynamic from 'next/dynamic';

    const DashboardChart = dynamic(() => import('./DashboardChart'), {
      ssr: false,
      loading: () => <div>Loading chart...</div>
    });

    // Route-based code splitting
    const LazyComponent = lazy(() => import('./LazyComponent'));
    ```

  </Tab>
  <Tab value="Image Optimization">
    ```tsx
    import Image from 'next/image';

    // Use Next.js Image component
    <Image
      src="/hero-image.jpg"
      alt="Hero Image"
      width={800}
      height={400}
      priority // For above-the-fold images
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
    ```

  </Tab>
  <Tab value="Bundle Analysis">
    ```bash
    # Analyze bundle size
    npm install -g @next/bundle-analyzer
    
    # In next.config.js
    const withBundleAnalyzer = require('@next/bundle-analyzer')({
      enabled: process.env.ANALYZE === 'true'
    });
    
    # Run analysis
    ANALYZE=true npm run build
    ```
  </Tab>
</Tabs>

### Problem: Memory Leaks in React Components

**Symptoms:**

- Increasing memory usage over time
- Browser tab crashes
- Slow interactions after extended use

**Solutions:**

```typescript
// 1. Cleanup subscriptions and timers
useEffect(() => {
  const timer = setInterval(() => {
    // Timer logic
  }, 1000);

  // Cleanup function
  return () => {
    clearInterval(timer);
  };
}, []);

// 2. Cleanup event listeners
useEffect(() => {
  const handleScroll = () => {
    // Scroll logic
  };

  window.addEventListener("scroll", handleScroll);

  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);

// 3. Use AbortController for API calls
useEffect(() => {
  const abortController = new AbortController();

  fetch("/api/data", { signal: abortController.signal })
    .then((response) => response.json())
    .then((data) => setData(data));

  return () => {
    abortController.abort();
  };
}, []);
```

## State Management Issues

### Problem: Prop Drilling

**Symptoms:**

- Passing props through multiple component levels
- Components receiving props they don't use
- Difficult to maintain state flow

**Solutions:**

<Tabs items={['Context API', 'Redux Toolkit', 'Component Composition']}>
  <Tab value="Context API">
    ```typescript
    // Create context
    const UserContext = createContext<User | null>(null);

    // Provider component
    export const UserProvider: FC<{ children: ReactNode }> = ({ children }) => {
      const [user, setUser] = useState<User | null>(null);

      return (
        <UserContext.Provider value={{ user, setUser }}>
          {children}
        </UserContext.Provider>
      );
    };

    // Custom hook
    export const useUser = () => {
      const context = useContext(UserContext);
      if (!context) {
        throw new Error('useUser must be used within UserProvider');
      }
      return context;
    };
    ```

  </Tab>
  <Tab value="Redux Toolkit">
    ```typescript
    // userSlice.ts
    import { createSlice, PayloadAction } from '@reduxjs/toolkit';

    interface User {
      id: string;
      name: string;
      email: string;
    }

    interface UserState {
      user: User | null;
    }

    const initialState: UserState = {
      user: null,
    };

    export const userSlice = createSlice({
      name: 'user',
      initialState,
      reducers: {
        setUser: (state, action: PayloadAction<User>) => {
          state.user = action.payload;
        },
        clearUser: (state) => {
          state.user = null;
        },
      },
    });

    export const { setUser, clearUser } = userSlice.actions;
    export default userSlice.reducer;

    // store.ts
    import { configureStore } from '@reduxjs/toolkit';
    import userReducer from './userSlice';

    export const store = configureStore({
      reducer: {
        user: userReducer,
      },
    });

    // Usage in component
    import { useSelector, useDispatch } from 'react-redux';
    import { setUser, clearUser } from './userSlice';

    const user = useSelector((state: any) => state.user.user);
    const dispatch = useDispatch();

    // Set user
    dispatch(setUser({ id: '1', name: 'John', email: 'john@example.com' }));

    // Clear user
    dispatch(clearUser());
    ```

  </Tab>
  <Tab value="Component Composition">
    ```tsx
    // Instead of prop drilling, use component composition
    <UserProvider>
      <Header>
        <UserMenu /> {/* Can access user context directly */}
      </Header>
      <Main>
        <UserProfile /> {/* Can access user context directly */}
      </Main>
    </UserProvider>
    ```
  </Tab>
</Tabs>

## TypeScript Issues

### Problem: Type Errors in Third-Party Libraries

**Symptoms:**

- TypeScript errors for external libraries
- Missing type definitions
- Inconsistent typing

**Solutions:**

```typescript
// 1. Install type definitions
npm install --save-dev @types/library-name

// 2. Create custom type declarations
// types/library-name.d.ts
declare module 'library-name' {
  export interface SomeInterface {
    property: string;
  }

  export function someFunction(param: string): SomeInterface;
}

// 3. Use module augmentation
declare module 'existing-library' {
  interface ExistingInterface {
    newProperty: string;
  }
}

// 4. Type assertion when necessary (use sparingly)
const result = (someLibraryFunction() as any) as ExpectedType;
```

### Problem: Complex Type Definitions

**Solutions:**

```typescript
// Use utility types for cleaner code
type CreateUserRequest = Omit<User, "id" | "createdAt" | "updatedAt">;
type UpdateUserRequest = Partial<Pick<User, "name" | "email">>;

// Generic types for reusability
interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

// Conditional types for advanced scenarios
type ApiEndpoint<T> = T extends "user"
  ? "/api/users"
  : T extends "order"
  ? "/api/orders"
  : never;
```

## CSS and Styling Issues

### Problem: CSS Specificity Conflicts

**Symptoms:**

- Styles not applying as expected
- Need for `!important` declarations
- Inconsistent component styling

**Solutions:**

<Cards>
  <Card title="ðŸŽ¨ CSS Modules" description="Scoped CSS to prevent conflicts" />
  <Card
    title="ðŸ’¨ Tailwind CSS"
    description="Utility-first approach eliminates specificity issues"
  />
  <Card title="ðŸ’… CSS-in-JS" description="Component-scoped styling solutions" />
  <Card
    title="ðŸŽ¯ BEM Methodology"
    description="Naming convention for maintainable CSS"
  />
</Cards>

```css
/* CSS Modules approach */
.container {
  padding: 1rem;
}

.container__title {
  font-size: 1.5rem;
  color: var(--primary-color);
}

/* Tailwind CSS approach */
<div className="p-4">
  <h1 className="text-xl text-primary">Title</h1>
</div>
```

## API Integration Issues

### Problem: Race Conditions in API Calls

**Symptoms:**

- Outdated data displaying
- Inconsistent UI state
- Multiple API calls for same data

**Solutions:**

```typescript
// Use TanStack Query for data fetching
import { useQuery } from "@tanstack/react-query";

const UserProfile = ({ userId }: { userId: string }) => {
  const {
    data: user,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error loading user</div>;

  return <div>{user.name}</div>;
};

// Manual race condition prevention
useEffect(() => {
  let isCurrent = true;

  fetchData().then((data) => {
    if (isCurrent) {
      setData(data);
    }
  });

  return () => {
    isCurrent = false;
  };
}, [dependency]);
```

## Build and Deployment Issues

### Problem: Environment Variable Issues

**Symptoms:**

- Variables undefined in production
- Different behavior between environments
- Security concerns with exposed secrets

**Solutions:**

```typescript
// next.config.js
module.exports = {
  env: {
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  },
  // For client-side variables, prefix with NEXT_PUBLIC_
  publicRuntimeConfig: {
    apiUrl: process.env.NEXT_PUBLIC_API_URL,
  },
};

// Use environment variables safely
const apiUrl = process.env.NEXT_PUBLIC_API_URL;
if (!apiUrl) {
  throw new Error("NEXT_PUBLIC_API_URL is required");
}

// Create environment-specific configs
const config = {
  development: {
    apiUrl: "http://localhost:3001",
  },
  production: {
    apiUrl: process.env.NEXT_PUBLIC_API_URL,
  },
}[process.env.NODE_ENV];
```

## Testing Issues

### Problem: Flaky Tests

**Symptoms:**

- Tests that sometimes pass, sometimes fail
- Time-dependent test failures
- Async operation test issues

**Solutions:**

```typescript
// 1. Use proper async/await patterns
test("loads user data", async () => {
  render(<UserProfile userId="123" />);

  // Wait for loading to finish
  await waitForElementToBeRemoved(screen.getByText("Loading..."));

  expect(screen.getByText("John Doe")).toBeInTheDocument();
});

// 2. Mock timers for time-dependent tests
beforeEach(() => {
  vi.useFakeTimers();
});

afterEach(() => {
  vi.useRealTimers();
});

test("shows notification after 3 seconds", () => {
  render(<NotificationComponent />);

  vi.advanceTimersByTime(3000);

  expect(screen.getByText("Notification")).toBeInTheDocument();
});

// 3. Use MSW for API mocking
import { rest } from "msw";
import { setupServer } from "msw/node";

const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) => {
    return res(ctx.json({ id: "123", name: "John Doe" }));
  })
);
```

## Accessibility Issues

### Problem: Poor Screen Reader Support

**Solutions:**

```tsx
// Use semantic HTML
<nav role="navigation" aria-label="Main navigation">
  <ul>
    <li><a href="/home" aria-current="page">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>

// Proper form labels
<form>
  <label htmlFor="email">Email Address</label>
  <input
    id="email"
    type="email"
    required
    aria-describedby="email-error"
  />
  <div id="email-error" role="alert">
    Please enter a valid email address
  </div>
</form>

// Focus management
const Modal = ({ isOpen, onClose, children }) => {
  const modalRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen && modalRef.current) {
      modalRef.current.focus();
    }
  }, [isOpen]);

  return isOpen ? (
    <div
      ref={modalRef}
      role="dialog"
      aria-modal="true"
      tabIndex={-1}
      onKeyDown={(e) => {
        if (e.key === 'Escape') onClose();
      }}
    >
      {children}
    </div>
  ) : null;
};
```

## Security Issues

### Problem: XSS Vulnerabilities

**Solutions:**

```typescript
// 1. Sanitize user input
import DOMPurify from "dompurify";

const SafeHTML = ({ html }: { html: string }) => {
  const cleanHTML = DOMPurify.sanitize(html);
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
};

// 2. Use Content Security Policy
// next.config.js
const securityHeaders = [
  {
    key: "Content-Security-Policy",
    value: "default-src 'self'; script-src 'self' 'unsafe-inline'",
  },
];

// 3. Validate and escape user input
const validateInput = (input: string) => {
  const sanitized = input.replace(/[<>]/g, "");
  return sanitized.trim();
};
```

<Callout type="warning">
  Remember to always validate user input on both client and server sides.
</Callout>

## Debugging Strategies

### Developer Tools Setup

```typescript
// React Developer Tools configuration
if (process.env.NODE_ENV === "development") {
  // Enable React DevTools profiling
  window.__REACT_DEVTOOLS_GLOBAL_HOOK__?.reactDevtoolsAgent?.addProfilingHook(
    (id, phase, actualDuration) => {
      console.log({ id, phase, actualDuration });
    }
  );
}

// Error boundary for debugging
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```
