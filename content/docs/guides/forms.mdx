---
title: Working with Forms
description: Build accessible, validated forms with React Hook Form and Zod
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

# üìù Working with Forms

<Callout type="info">
  Learn how to build robust forms with validation, error handling, and
  accessibility using React Hook Form and Zod.
</Callout>

<Callout type="warn">
  Looking for **Server Actions** with forms? See the [Data Fetching & Server
  Actions](/docs/guides/data-fetching#-server-actions-nextjs) guide for
  `useActionState` and server-side form handling.
</Callout>

## üõ†Ô∏è Our Form Stack

| Library             | Purpose                                                                   |
| ------------------- | ------------------------------------------------------------------------- |
| **React Hook Form** | Client-side form state management                                         |
| **Zod**             | Schema validation                                                         |
| **Shadcn Form**     | Accessible form components                                                |
| **Server Actions**  | Server-side submissions (see [Data Fetching](/docs/guides/data-fetching)) |

## üìù Basic Form Setup

<Steps>

<Step>
### üìê Define Your Schema

Create a Zod schema for validation:

```tsx
import { z } from "zod";

const contactFormSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email"),
  message: z.string().min(10, "Message must be at least 10 characters"),
  priority: z.enum(["low", "medium", "high"]),
});

type ContactFormValues = z.infer<typeof contactFormSchema>;
```

</Step>

<Step>
### ‚öôÔ∏è Create the Form Component

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";

export function ContactForm() {
  const form = useForm<ContactFormValues>({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      message: "",
      priority: "medium",
    },
  });

  async function onSubmit(data: ContactFormValues) {
    try {
      // Submit to API
      await submitContactForm(data);
      form.reset();
    } catch (error) {
      form.setError("root", {
        message: "Failed to submit. Please try again.",
      });
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="Your name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" placeholder="you@example.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea placeholder="How can we help?" {...field} />
              </FormControl>
              <FormDescription>Minimum 10 characters required.</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? "Sending..." : "Send Message"}
        </Button>
      </form>
    </Form>
  );
}
```

</Step>

<Step>
### üîÑ Handle Form States

Always handle loading, error, and success states:

```tsx
export function ContactForm() {
  const [isSuccess, setIsSuccess] = useState(false);
  const form = useForm<ContactFormValues>({
    resolver: zodResolver(contactFormSchema),
  });

  async function onSubmit(data: ContactFormValues) {
    try {
      await submitContactForm(data);
      setIsSuccess(true);
      form.reset();
    } catch (error) {
      form.setError("root", {
        message: "Submission failed. Please try again.",
      });
    }
  }

  if (isSuccess) {
    return (
      <div className="rounded-lg bg-green-50 p-4 text-green-800">
        <h3 className="font-semibold">Thank you!</h3>
        <p>We'll get back to you soon.</p>
        <Button variant="outline" onClick={() => setIsSuccess(false)}>
          Send another message
        </Button>
      </div>
    );
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {form.formState.errors.root && (
          <div className="rounded-lg bg-red-50 p-4 text-red-800">
            {form.formState.errors.root.message}
          </div>
        )}
        {/* Form fields... */}
      </form>
    </Form>
  );
}
```

</Step>

</Steps>

## üöÄ Advanced Patterns

### üîÅ Dynamic Form Fields

Add or remove fields dynamically:

```tsx
import { useFieldArray } from "react-hook-form";

const schema = z.object({
  items: z
    .array(
      z.object({
        name: z.string().min(1),
        quantity: z.number().min(1),
      })
    )
    .min(1, "At least one item required"),
});

function OrderForm() {
  const form = useForm({
    resolver: zodResolver(schema),
    defaultValues: { items: [{ name: "", quantity: 1 }] },
  });

  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: "items",
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {fields.map((field, index) => (
          <div key={field.id} className="flex gap-4">
            <FormField
              control={form.control}
              name={`items.${index}.name`}
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input {...field} placeholder="Item name" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <Button
              type="button"
              variant="destructive"
              onClick={() => remove(index)}
            >
              Remove
            </Button>
          </div>
        ))}
        <Button type="button" onClick={() => append({ name: "", quantity: 1 })}>
          Add Item
        </Button>
      </form>
    </Form>
  );
}
```

### Async Validation

Validate against server data:

```tsx
const usernameSchema = z.object({
  username: z
    .string()
    .min(3)
    .refine(
      async (username) => {
        const isAvailable = await checkUsernameAvailability(username);
        return isAvailable;
      },
      { message: "Username is already taken" }
    ),
});
```

### Multi-Step Forms

```tsx
type Step = "details" | "address" | "payment" | "confirm";

function MultiStepForm() {
  const [step, setStep] = useState<Step>("details");
  const form = useForm({
    resolver: zodResolver(fullSchema),
    mode: "onChange",
  });

  const steps: Record<Step, React.ReactNode> = {
    details: <DetailsStep />,
    address: <AddressStep />,
    payment: <PaymentStep />,
    confirm: <ConfirmStep />,
  };

  async function handleNext() {
    const fieldsToValidate = getFieldsForStep(step);
    const isValid = await form.trigger(fieldsToValidate);
    if (isValid) {
      setStep(getNextStep(step));
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <StepIndicator currentStep={step} />
        {steps[step]}
        <div className="flex justify-between">
          <Button type="button" onClick={handlePrevious}>
            Back
          </Button>
          {step === "confirm" ? (
            <Button type="submit">Submit</Button>
          ) : (
            <Button type="button" onClick={handleNext}>
              Next
            </Button>
          )}
        </div>
      </form>
    </Form>
  );
}
```

## ‚ôø Form Accessibility

<Callout type="warn">Always ensure forms are accessible to all users.</Callout>

### Required Practices

1. **Label all inputs** - Every input must have an associated label
2. **Error announcements** - Use `aria-describedby` for error messages
3. **Focus management** - Move focus to first error on submit
4. **Keyboard navigation** - All form controls must be keyboard accessible

```tsx
<FormField
  control={form.control}
  name="email"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        Email <span className="text-red-500">*</span>
      </FormLabel>
      <FormControl>
        <Input
          {...field}
          type="email"
          aria-required="true"
          aria-invalid={!!form.formState.errors.email}
          aria-describedby={
            form.formState.errors.email ? "email-error" : undefined
          }
        />
      </FormControl>
      <FormMessage id="email-error" />
    </FormItem>
  )}
/>
```

## üìã Common Validation Patterns

```tsx
const validationPatterns = {
  // Phone number (Egyptian)
  phone: z.string().regex(/^(\+20|0)?1[0125]\d{8}$/, "Invalid phone number"),

  // Password strength
  password: z
    .string()
    .min(8, "At least 8 characters")
    .regex(/[A-Z]/, "At least one uppercase letter")
    .regex(/[a-z]/, "At least one lowercase letter")
    .regex(/[0-9]/, "At least one number")
    .regex(/[^A-Za-z0-9]/, "At least one special character"),

  // URL
  url: z.string().url("Please enter a valid URL"),

  // Date in past
  birthDate: z.date().max(new Date(), "Date must be in the past"),

  // Confirm password
  confirmPassword: z.string(),
}.refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});
```

## üß™ Testing Forms

```tsx
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ContactForm } from "./contact-form";

describe("ContactForm", () => {
  it("shows validation errors for empty fields", async () => {
    render(<ContactForm />);

    await userEvent.click(screen.getByRole("button", { name: /send/i }));

    await waitFor(() => {
      expect(screen.getByText(/name must be at least/i)).toBeInTheDocument();
    });
  });

  it("submits valid form data", async () => {
    const onSubmit = vi.fn();
    render(<ContactForm onSubmit={onSubmit} />);

    await userEvent.type(screen.getByLabelText(/name/i), "John Doe");
    await userEvent.type(screen.getByLabelText(/email/i), "john@test.com");
    await userEvent.type(
      screen.getByLabelText(/message/i),
      "Hello, this is my message!"
    );
    await userEvent.click(screen.getByRole("button", { name: /send/i }));

    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        name: "John Doe",
        email: "john@test.com",
        message: "Hello, this is my message!",
        priority: "medium",
      });
    });
  });
});
```

## üëâ Next Steps

- üì° [Data Fetching](/docs/guides/data-fetching) - Submit forms to APIs
- üîê [Authentication](/docs/guides/authentication) - Build login forms
- üß™ [Testing Guide](/docs/guides/testing) - Test your forms thoroughly
