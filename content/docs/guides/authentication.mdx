---
title: Authentication
description: Implement secure authentication with NextAuth.js and role-based access control
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# üîê Authentication

<Callout type="info">
  Learn how to implement secure authentication, authorization, and session
  management using NextAuth.js (Auth.js) with our backend APIs.
</Callout>

## üõ†Ô∏è Authentication Stack

| Library         | Purpose                  |
| --------------- | ------------------------ |
| **NextAuth.js** | Authentication framework |
| **JWT**         | Token-based sessions     |
| **Middleware**  | Route protection         |

## ‚öôÔ∏è Setup NextAuth.js

### üì¶ Install Dependencies

```bash
npm install next-auth@beta
```

### üìã Configure Auth

```tsx
// src/auth.ts
import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import { z } from "zod";

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

export const { auth, handlers, signIn, signOut } = NextAuth({
  providers: [
    Credentials({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        const parsed = loginSchema.safeParse(credentials);
        if (!parsed.success) return null;

        const response = await fetch(`${process.env.API_URL}/auth/login`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(parsed.data),
        });

        if (!response.ok) return null;

        const user = await response.json();
        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          accessToken: user.accessToken,
        };
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
        token.accessToken = user.accessToken;
      }
      return token;
    },
    async session({ session, token }) {
      session.user.id = token.id as string;
      session.user.role = token.role as string;
      session.accessToken = token.accessToken as string;
      return session;
    },
  },
  pages: {
    signIn: "/login",
    error: "/login",
  },
  session: {
    strategy: "jwt",
    maxAge: 24 * 60 * 60, // 24 hours
  },
});
```

### üîå Add API Route

```tsx
// src/app/api/auth/[...nextauth]/route.ts
import { handlers } from "@/auth";

export const { GET, POST } = handlers;
```

## üìù Login Form

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import { useState } from "react";

const loginSchema = z.object({
  email: z.string().email("Please enter a valid email"),
  password: z.string().min(8, "Password must be at least 8 characters"),
});

type LoginFormValues = z.infer<typeof loginSchema>;

export function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") || "/dashboard";
  const [error, setError] = useState<string | null>(null);

  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { email: "", password: "" },
  });

  async function onSubmit(data: LoginFormValues) {
    setError(null);

    const result = await signIn("credentials", {
      email: data.email,
      password: data.password,
      redirect: false,
    });

    if (result?.error) {
      setError("Invalid email or password");
      return;
    }

    router.push(callbackUrl);
    router.refresh();
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
      {error && (
        <div className="rounded-lg bg-destructive/10 p-3 text-destructive">
          {error}
        </div>
      )}

      <FormField
        control={form.control}
        name="email"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Email</FormLabel>
            <FormControl>
              <Input type="email" placeholder="you@example.com" {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      <FormField
        control={form.control}
        name="password"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Password</FormLabel>
            <FormControl>
              <Input type="password" {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      <Button
        type="submit"
        className="w-full"
        disabled={form.formState.isSubmitting}
      >
        {form.formState.isSubmitting ? "Signing in..." : "Sign in"}
      </Button>
    </form>
  );
}
```

## üõ°Ô∏è Route Protection

### üöß Middleware Protection

```tsx
// src/middleware.ts
import { auth } from "@/auth";
import { NextResponse } from "next/server";

// Routes that require authentication
const protectedRoutes = ["/dashboard", "/settings", "/admin"];

// Routes that require specific roles
const roleRoutes: Record<string, string[]> = {
  "/admin": ["admin"],
  "/manager": ["admin", "manager"],
};

export default auth((req) => {
  const { nextUrl, auth: session } = req;
  const isLoggedIn = !!session?.user;
  const pathname = nextUrl.pathname;

  // Check if route requires authentication
  const isProtected = protectedRoutes.some((route) =>
    pathname.startsWith(route)
  );

  if (isProtected && !isLoggedIn) {
    const loginUrl = new URL("/login", nextUrl.origin);
    loginUrl.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(loginUrl);
  }

  // Check role-based access
  for (const [route, roles] of Object.entries(roleRoutes)) {
    if (pathname.startsWith(route)) {
      const userRole = session?.user?.role;
      if (!userRole || !roles.includes(userRole)) {
        return NextResponse.redirect(new URL("/unauthorized", nextUrl.origin));
      }
    }
  }

  return NextResponse.next();
});

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};
```

### Server Component Protection

```tsx
// src/app/dashboard/page.tsx
import { auth } from "@/auth";
import { redirect } from "next/navigation";

export default async function DashboardPage() {
  const session = await auth();

  if (!session) {
    redirect("/login");
  }

  return (
    <div>
      <h1>Welcome, {session.user.name}</h1>
      {/* Dashboard content */}
    </div>
  );
}
```

### Client Component Protection

```tsx
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export function ProtectedComponent() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  if (status === "loading") {
    return <LoadingSpinner />;
  }

  if (!session) {
    return null;
  }

  return <div>{/* Protected content */}</div>;
}
```

## üë• Role-Based Access Control

### Permission Hook

```tsx
// src/hooks/use-permissions.ts
import { useSession } from "next-auth/react";

type Role = "admin" | "manager" | "user" | "guest";

const roleHierarchy: Record<Role, number> = {
  admin: 4,
  manager: 3,
  user: 2,
  guest: 1,
};

export function usePermissions() {
  const { data: session } = useSession();
  const userRole = (session?.user?.role || "guest") as Role;

  function hasRole(requiredRole: Role): boolean {
    return roleHierarchy[userRole] >= roleHierarchy[requiredRole];
  }

  function hasAnyRole(roles: Role[]): boolean {
    return roles.some((role) => hasRole(role));
  }

  return {
    role: userRole,
    isAdmin: userRole === "admin",
    isManager: hasRole("manager"),
    hasRole,
    hasAnyRole,
  };
}
```

### Permission Component

```tsx
// src/components/permission-gate.tsx
"use client";

import { usePermissions } from "@/hooks/use-permissions";

interface PermissionGateProps {
  requiredRole: Role;
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function PermissionGate({
  requiredRole,
  children,
  fallback = null,
}: PermissionGateProps) {
  const { hasRole } = usePermissions();

  if (!hasRole(requiredRole)) {
    return fallback;
  }

  return children;
}

// Usage
function AdminPanel() {
  return (
    <PermissionGate
      requiredRole="admin"
      fallback={<p>You don't have permission to view this.</p>}
    >
      <AdminDashboard />
    </PermissionGate>
  );
}
```

## üë§ Session Provider

```tsx
// src/app/providers.tsx
"use client";

import { SessionProvider } from "next-auth/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
```

## üîë API Authentication

### üì§ Adding Token to Requests

```tsx
// src/lib/api.ts
import { getSession } from "next-auth/react";

const BASE_URL = process.env.NEXT_PUBLIC_API_URL;

async function getAuthHeaders(): Promise<HeadersInit> {
  const session = await getSession();
  const headers: HeadersInit = {
    "Content-Type": "application/json",
  };

  if (session?.accessToken) {
    headers.Authorization = `Bearer ${session.accessToken}`;
  }

  return headers;
}

export const api = {
  async get<T>(endpoint: string): Promise<T> {
    const headers = await getAuthHeaders();
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: "GET",
      headers,
    });
    if (!response.ok) throw new Error(response.statusText);
    return response.json();
  },

  async post<T>(endpoint: string, data?: unknown): Promise<T> {
    const headers = await getAuthHeaders();
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: "POST",
      headers,
      body: data ? JSON.stringify(data) : undefined,
    });
    if (!response.ok) throw new Error(response.statusText);
    return response.json();
  },
};
```

## üîí Security Best Practices

<Callout type="error">Always follow these security practices.</Callout>

### Do's ‚úÖ

- Store tokens in HTTP-only cookies (NextAuth handles this)
- Use HTTPS in production
- Implement CSRF protection
- Set appropriate session timeouts
- Validate and sanitize all user inputs
- Use secure password requirements

### Don'ts ‚ùå

- Never store tokens in localStorage
- Never expose sensitive data in URLs
- Never trust client-side validation alone
- Never log sensitive user data
- Never skip input sanitization

## üëâ Next Steps

- üõ°Ô∏è [Security Reference](/docs/reference/security) - Security policies
- üì° [Data Fetching](/docs/guides/data-fetching) - Authenticated API calls
- üìù [Forms Guide](/docs/guides/forms) - Build login forms
