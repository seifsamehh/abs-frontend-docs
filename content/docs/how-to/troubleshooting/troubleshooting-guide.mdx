---
title: Troubleshooting Guide
description: Common frontend problems and their proven solutions
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# Troubleshooting Guide

<Callout type="info">
  This guide documents common frontend problems we encounter and their proven
  solutions. Learn from our experience to avoid common pitfalls.
</Callout>

## Performance Issues

### Slow Page Load Times

**Symptoms:**

- High First Contentful Paint (FCP) times
- Poor Lighthouse scores
- User complaints about slow loading

**Solutions:**

<Tabs items={['‚úÇÔ∏è Code Splitting', 'üñºÔ∏è Image Optimization', 'üìä Bundle Analysis']}>
  <Tab value="‚úÇÔ∏è Code Splitting">
    ```typescript
    // Use dynamic imports for code splitting
    import dynamic from 'next/dynamic';

    const DashboardChart = dynamic(() => import('./DashboardChart'), {
      ssr: false,
      loading: () => <div>Loading chart...</div>
    });

    // Route-based code splitting with React.lazy
    const LazyComponent = lazy(() => import('./LazyComponent'));
    ```

</Tab>
  <Tab value="üñºÔ∏è Image Optimization">
    ```tsx
    import Image from 'next/image';

    // Always use Next.js Image component
    <Image
      src="/hero-image.jpg"
      alt="Hero Image"
      width={800}
      height={400}
      priority // For above-the-fold images
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
    ```

</Tab>
  <Tab value="üìä Bundle Analysis">
    ```bash
    # Install bundle analyzer
    pnpm add -D @next/bundle-analyzer

    # In next.config.js
    const withBundleAnalyzer = require('@next/bundle-analyzer')({
      enabled: process.env.ANALYZE === 'true'
    });

    # Run analysis
    ANALYZE=true pnpm build
    ```

</Tab>
</Tabs>

### Memory Leaks

**Symptoms:**

- Increasing memory usage over time
- Browser tab crashes
- Slow interactions after extended use

**Solutions:**

```typescript
// 1. Cleanup subscriptions and timers
useEffect(() => {
  const timer = setInterval(() => {
    // Timer logic
  }, 1000);

  return () => clearInterval(timer);
}, []);

// 2. Cleanup event listeners
useEffect(() => {
  const handleScroll = () => {
    /* scroll logic */
  };
  window.addEventListener("scroll", handleScroll);

  return () => window.removeEventListener("scroll", handleScroll);
}, []);

// 3. Use AbortController for API calls
useEffect(() => {
  const controller = new AbortController();

  fetch("/api/data", { signal: controller.signal })
    .then((res) => res.json())
    .then(setData);

  return () => controller.abort();
}, []);
```

---

## State Management Issues

### Prop Drilling

**Problem:** Passing props through multiple component levels.

<Tabs items={['üîó Context API', 'üóÉÔ∏è Redux Toolkit', 'üß© Composition']}>
  <Tab value="üîó Context API">
    ```typescript
    // Create focused context
    const UserContext = createContext<User | null>(null);

    // Provider component
    export function UserProvider({ children }: { children: React.ReactNode }) {
      const [user, setUser] = useState<User | null>(null);

      return (
        <UserContext.Provider value={user}>
          {children}
        </UserContext.Provider>
      );
    }

    // Custom hook for consuming
    export function useUser() {
      const context = useContext(UserContext);
      if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
      }
      return context;
    }
    ```

</Tab>
  <Tab value="üóÉÔ∏è Redux Toolkit">
    ```typescript
    // Use Redux for complex global state
    import { createSlice } from '@reduxjs/toolkit';

    const userSlice = createSlice({
      name: 'user',
      initialState: { data: null, loading: false },
      reducers: {
        setUser: (state, action) => {
          state.data = action.payload;
        },
      },
    });
    ```

</Tab>
  <Tab value="üß© Composition">
    ```tsx
    // Use composition to avoid drilling
    function Dashboard() {
      const user = useUser();
      
      return (
        <Layout>
          <Header user={user} />
          <Sidebar>
            <UserProfile user={user} />
          </Sidebar>
          <Content>
            <UserDashboard user={user} />
          </Content>
        </Layout>
      );
    }
    ```
</Tab>
</Tabs>

### Stale State in Closures

**Problem:** Event handlers capturing stale state values.

```typescript
// ‚ùå Problem: count is always 0 in the handler
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const handler = () => {
      console.log(count); // Always 0!
    };
    window.addEventListener("click", handler);
    return () => window.removeEventListener("click", handler);
  }, []); // Empty deps = stale closure
}

// ‚úÖ Solution 1: Include dependency
useEffect(() => {
  const handler = () => console.log(count);
  window.addEventListener("click", handler);
  return () => window.removeEventListener("click", handler);
}, [count]); // Re-subscribe when count changes

// ‚úÖ Solution 2: Use ref for latest value
const countRef = useRef(count);
useEffect(() => {
  countRef.current = count;
}, [count]);
```

---

## Data Fetching Issues

### Race Conditions

**Problem:** Multiple requests causing inconsistent state.

```typescript
// ‚úÖ Using TanStack Query (recommended)
const { data } = useQuery({
  queryKey: ["user", userId],
  queryFn: () => fetchUser(userId),
  // Automatic deduplication and caching
});

// ‚úÖ Manual AbortController approach
useEffect(() => {
  const controller = new AbortController();
  let cancelled = false;

  async function fetchData() {
    try {
      const response = await fetch(`/api/users/${userId}`, {
        signal: controller.signal,
      });
      const data = await response.json();
      if (!cancelled) setUser(data);
    } catch (error) {
      if (error.name !== "AbortError") {
        setError(error);
      }
    }
  }

  fetchData();
  return () => {
    cancelled = true;
    controller.abort();
  };
}, [userId]);
```

### Infinite Re-renders

**Problem:** Data fetching causing render loops.

```typescript
// ‚ùå Problem: Object reference changes each render
useEffect(() => {
  fetchData(options); // options = { limit: 10 } recreated each render
}, [options]); // Triggers infinite loop

// ‚úÖ Solution: Memoize or use primitive deps
const memoizedOptions = useMemo(() => ({ limit: 10 }), []);
useEffect(() => {
  fetchData(memoizedOptions);
}, [memoizedOptions]);

// ‚úÖ Better: Use individual primitives
useEffect(() => {
  fetchData({ limit, offset });
}, [limit, offset]);
```

---

## Testing Issues

### Tests Failing Intermittently

**Common Causes:**

- Async operations not properly awaited
- Test isolation issues
- Timer-dependent code

```typescript
// ‚úÖ Proper async testing
it("should load user data", async () => {
  render(<UserProfile userId="123" />);

  // Wait for element to appear
  await waitFor(() => {
    expect(screen.getByText("John Doe")).toBeInTheDocument();
  });
});

// ‚úÖ Mock timers for time-dependent tests
it("should debounce search", async () => {
  vi.useFakeTimers();

  render(<SearchInput />);
  await userEvent.type(screen.getByRole("textbox"), "test");

  // Fast-forward debounce timer
  vi.advanceTimersByTime(300);

  await waitFor(() => {
    expect(mockSearch).toHaveBeenCalledWith("test");
  });

  vi.useRealTimers();
});
```

### Mocking Not Working

```typescript
// ‚úÖ Proper module mocking
vi.mock("@/lib/api", () => ({
  fetchUser: vi.fn(),
}));

// Import AFTER mocking
import { fetchUser } from "@/lib/api";

beforeEach(() => {
  vi.mocked(fetchUser).mockResolvedValue({ id: "1", name: "Test" });
});

afterEach(() => {
  vi.clearAllMocks();
});
```

---

## Deployment Issues

### Build Failures

**Common Causes and Solutions:**

| Error              | Cause                          | Solution                                                       |
| ------------------ | ------------------------------ | -------------------------------------------------------------- |
| `Type error`       | TypeScript compilation failure | Fix type errors locally first                                  |
| `Module not found` | Missing dependency             | Check `package.json`, run `pnpm install`                       |
| `Out of memory`    | Large build                    | Increase Node memory: `NODE_OPTIONS=--max_old_space_size=4096` |
| `ESLint errors`    | Code quality issues            | Run `pnpm lint --fix` locally                                  |

### Environment Variables Missing

```typescript
// ‚úÖ Validate env vars at build time
// src/lib/env.ts
import { z } from "zod";

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string().min(32),
  NEXT_PUBLIC_API_URL: z.string().url(),
});

// Throws at build time if invalid
export const env = envSchema.parse(process.env);
```

### Hydration Mismatches

**Common Causes:**

- Server/client rendering different content
- Using browser-only APIs during SSR

```typescript
// ‚ùå Problem: window is undefined on server
function Component() {
  const width = window.innerWidth; // Crashes on server!
}

// ‚úÖ Solution 1: useEffect
function Component() {
  const [width, setWidth] = useState(0);

  useEffect(() => {
    setWidth(window.innerWidth);
  }, []);
}

// ‚úÖ Solution 2: Dynamic import with ssr: false
const ClientOnlyComponent = dynamic(() => import("./ClientOnlyComponent"), {
  ssr: false,
});
```

---

## TanStack Query v5 Migration Issues

<Callout type="warn">
  TanStack Query v5 has significant breaking changes from v4. These are the most
  common issues encountered during migration.
</Callout>

### Issue: `isLoading` Always False

**Symptom:** `isLoading` is always `false`, even during initial fetch.

**Cause:** In v5, `isLoading` was renamed to `isPending` for initial loading state.

```tsx
// ‚ùå v4 code (broken in v5)
const { data, isLoading } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
});

if (isLoading) return <Skeleton />; // Never shows!

// ‚úÖ v5 fix
const { data, isPending } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
});

if (isPending) return <Skeleton />; // Works correctly
```

### Issue: `cacheTime` Not Working

**Symptom:** Cache seems to expire immediately or setting `cacheTime` has no effect.

**Cause:** `cacheTime` was renamed to `gcTime` (garbage collection time).

```tsx
// ‚ùå v4 code (broken in v5)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      cacheTime: 5 * 60 * 1000, // Ignored in v5!
    },
  },
});

// ‚úÖ v5 fix
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 5 * 60 * 1000, // Garbage collection time
      staleTime: 60 * 1000, // When data becomes stale
    },
  },
});
```

### Issue: TypeScript Errors with Query Options

**Symptom:** TypeScript errors about query options shape.

**Cause:** v5 requires options to be passed as a single object.

```tsx
// ‚ùå v4 syntax (broken in v5)
useQuery(["users"], fetchUsers, { staleTime: 5000 });

// ‚úÖ v5 syntax
useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  staleTime: 5000,
});
```

### Issue: `onSuccess`/`onError` Callbacks Not Firing

**Symptom:** Callbacks defined in `useQuery` options never execute.

**Cause:** Per-query callbacks were removed in v5. Use global callbacks or handle in the component.

```tsx
// ‚ùå v4 code (removed in v5)
useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  onSuccess: (data) => {
    toast.success("Users loaded"); // Never fires!
  },
  onError: (error) => {
    toast.error(error.message);
  },
});

// ‚úÖ v5 fix - Option 1: Handle in component
const { data, error, isSuccess, isError } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
});

useEffect(() => {
  if (isSuccess) toast.success("Users loaded");
  if (isError) toast.error(error.message);
}, [isSuccess, isError, error]);

// ‚úÖ v5 fix - Option 2: Global callbacks in QueryClient
const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error) => {
      toast.error(`Error: ${error.message}`);
    },
  }),
});
```

### Issue: `isInitialLoading` Undefined

**Symptom:** `isInitialLoading` is undefined.

**Cause:** Removed in v5. Use the combination of flags instead.

```tsx
// ‚ùå v4 code (removed in v5)
const { isInitialLoading } = useQuery({...});

// ‚úÖ v5 fix
const { isPending, isFetching } = useQuery({...});

// isInitialLoading equivalent
const isInitialLoading = isPending && isFetching;

// Or for showing different states:
if (isPending) return <Skeleton />;           // Initial load
if (isFetching) return <RefreshingIndicator />; // Background refetch
```

### Issue: Infinite Query `getNextPageParam` Signature

**Symptom:** Type errors with `getNextPageParam` function.

**Cause:** Signature changed in v5 to include all pages.

```tsx
// ‚ùå v4 signature
useInfiniteQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  getNextPageParam: (lastPage) => lastPage.nextCursor,
});

// ‚úÖ v5 signature
useInfiniteQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  initialPageParam: null,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    return lastPage.hasMore ? lastPage.nextCursor : undefined;
  },
});
```

### Quick Migration Checklist

| v4 API                 | v5 API                    | Notes                                                                  |
| ---------------------- | ------------------------- | ---------------------------------------------------------------------- |
| `cacheTime`            | `gcTime`                  | Garbage collection time                                                |
| `isLoading` (initial)  | `isPending`               | Initial loading state                                                  |
| `isInitialLoading`     | `isPending && isFetching` | Removed                                                                |
| `status: 'loading'`    | `status: 'pending'`       | Status enum change                                                     |
| `onSuccess` in options | Handle in component       | Removed from query options                                             |
| `onError` in options   | Handle in component       | Removed from query options                                             |
| Three arguments        | Single options object     | `useQuery(key, fn, opts)` ‚Üí `useQuery({ queryKey, queryFn, ...opts })` |

---

## Quick Diagnosis Checklist

<Callout type="warn">
  Before diving deep, run through this quick checklist:
</Callout>

1. **Clear caches:** `rm -rf .next node_modules/.cache`
2. **Reinstall dependencies:** `rm -rf node_modules && pnpm install`
3. **Check Node version:** `node -v` (should match `.nvmrc`)
4. **Check for TypeScript errors:** `pnpm tsc --noEmit`
5. **Check for lint errors:** `pnpm lint`
6. **Review recent changes:** `git diff HEAD~5`
