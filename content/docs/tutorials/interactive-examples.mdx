---
title: Live Examples & Playgrounds
description: Interactive code examples organized by skill level - beginner, intermediate, and advanced
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

# üéÆ Live Examples & Playgrounds

<Callout type="info">
  **Learn by Doing!** The best way to understand React patterns is through
  hands-on practice. Each example below includes **interactive playgrounds**
  where you can edit code and see changes live!
</Callout>

---

## üìä Choose Your Level

<Cards>
  <Card
    title="üî∞ Beginner"
    description="Start here! Learn useState, props, events, and basic rendering"
    href="#-beginner-examples"
  />
  <Card
    title="üî∑ Intermediate"
    description="Level up with useEffect, custom hooks, and form validation"
    href="#-intermediate-examples"
  />
  <Card
    title="üî∂ Advanced"
    description="Master useReducer, Context API, optimistic updates, and more"
    href="#-advanced-examples"
  />
</Cards>

---

## üî∞ Beginner Examples

<Callout type="tip">
  **Perfect for:** Developers new to React or those wanting to solidify
  fundamentals. Each example focuses on one or two core concepts.
</Callout>

### Hello World with Props

Learn how to pass data between components using props, and how to update the UI with useState.

<BeginnerHelloWorldPlayground />

**Key Concepts:**

- Components as reusable building blocks
- Props for passing data down
- Default prop values
- `useState` for interactive input

---

### Toggle Button

Master conditional rendering and boolean state management with an interactive toggle switch.

<BeginnerTogglePlayground />

**Key Concepts:**

- Boolean state with `useState`
- Event handlers with `onClick`
- Conditional rendering with `&&` operator
- CSS transitions for smooth animations

---

### Simple List Rendering

Learn to work with arrays in React state - adding, removing, and rendering list items.

<BeginnerListPlayground />

**Key Concepts:**

- Array state management
- `map()` for rendering lists
- Unique `key` props for list items
- `filter()` for removing items
- Spread operator for immutable updates

---

### üî¢ Counter Example

The classic React example - understand how state updates trigger re-renders.

<CounterPlayground />

**Key Concepts:**

- `useState` hook for state management
- Event handlers with `onClick`
- Immutable state updates with setter functions

---

## üî∑ Intermediate Examples

<Callout type="info">
  **Perfect for:** Developers comfortable with basics who want to learn
  real-world patterns. These examples combine multiple concepts.
</Callout>

### Data Fetching with useEffect

Learn the complete data fetching pattern including loading states, error handling, and retry functionality.

<IntermediateUseEffectPlayground />

**Key Concepts:**

- `useEffect` for side effects
- Async/await with React state
- Loading, success, and error states
- Cleanup and the dependency array
- Retry functionality

---

### Custom Hooks

Extract reusable logic into custom hooks - the key to clean, maintainable React code.

<IntermediateCustomHookPlayground />

**Key Concepts:**

- Creating custom hooks (naming with `use`)
- `useLocalStorage` for persistent state
- `useCounter` for reusable counter logic
- Composition over duplication
- Hook return patterns (object vs array)

---

### Form with Validation

Build a real registration form with field-level validation, touched states, and error messages.

<IntermediateFormValidationPlayground />

**Key Concepts:**

- Complex form state management
- Field-level validation rules
- `touched` state for UX
- `onBlur` validation timing
- Form submission handling
- Conditional error display

---

### üìù Contact Form Example

A simpler form example showing controlled inputs and form submission.

<FormPlayground />

**Key Concepts:**

- Controlled inputs with `value` and `onChange`
- Form submission with `onSubmit`
- Conditional rendering based on state

---

## üî∂ Advanced Examples

<Callout type="warn">
  **Perfect for:** Experienced developers ready for production-level patterns.
  These examples demonstrate complex state management and performance
  optimization.
</Callout>

### Shopping Cart with useReducer + Context

Build a complete shopping cart using useReducer for complex state logic and Context for global state.

<AdvancedReducerContextPlayground />

**Key Concepts:**

- `useReducer` for complex state transitions
- Action types and payloads
- Context API for global state
- Custom hooks for context consumption
- Immutable nested updates
- Computed values (totals, counts)

---

### Debounced Search with AbortController

Implement a performant search with debouncing and request cancellation - essential for production apps.

<AdvancedDebouncedSearchPlayground />

**Key Concepts:**

- Debouncing for performance
- `AbortController` for request cancellation
- `useRef` for mutable values
- `useCallback` for stable references
- Race condition prevention
- Cleanup on unmount

---

### Optimistic Updates with Rollback

Learn the pattern used by Twitter, Facebook, and other major apps - update the UI immediately and rollback on error.

<AdvancedOptimisticUpdatePlayground />

**Key Concepts:**

- Optimistic UI updates
- Error rollback strategies
- Pending state tracking
- Toast notifications
- Preserving list order on rollback
- Handling concurrent operations

---

### ‚úÖ Todo App (Complete Example)

A comprehensive todo application combining multiple patterns you've learned.

<TodoPlayground />

**Key Concepts:**

- Array state management (add, remove, update)
- Mapping over arrays to render lists
- Using unique `key` props for list items
- Computed values for remaining count

### Example 1: Building a Counter Component

Let's start with the classic React example - a counter. This teaches **state management** fundamentals.

<Tabs items={['üíª Code', 'üìö Explanation', 'üéÆ Try It']}>
<Tab value="üíª Code">
```tsx title="Counter.tsx"
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

export function Counter() {
  const [count, setCount] = useState(0);

return (

<Card className="p-6 text-center">
  <h2 className="text-2xl font-bold mb-4">Count: {count}</h2>
  <div className="flex gap-2 justify-center">
    <Button variant="outline" onClick={() => setCount(count - 1)}>
      Decrease
    </Button>
    <Button onClick={() => setCount(count + 1)}>Increase</Button>
    <Button variant="secondary" onClick={() => setCount(0)}>
      Reset
    </Button>
  </div>
</Card>
); }

````
</Tab>
<Tab value="üìö Explanation">
**Key Concepts:**

1. **`'use client'`** - This is required because we use `useState` (client-side interactivity)
2. **`useState(0)`** - Initialize state with 0, returns `[value, setter]`
3. **Immutable Updates** - We never modify `count` directly, always use `setCount`
4. **Event Handlers** - Arrow functions in `onClick` to pass the new value

**Why This Pattern?**

- Keeps state local to the component
- Easy to test and reason about
- React handles re-rendering automatically

</Tab>
<Tab value="üéÆ Try It">
**üéØ Challenges to Try:**

1. Add a "Double" button that multiplies the count by 2
2. Add a maximum limit (can't go above 100)
3. Add color change when count is negative (red) or positive (green)
4. Store the count in localStorage so it persists on refresh

```tsx title="Challenge Solution: With Limits"
const [count, setCount] = useState(0);
const MAX = 100;
const MIN = -100;

const increment = () => setCount(prev => Math.min(prev + 1, MAX));
const decrement = () => setCount(prev => Math.max(prev - 1, MIN));
````

</Tab>
</Tabs>

---

### Example 2: Fetching Data with React Query

Real applications need to fetch data. Here's how we do it at ABS.

<Tabs items={['ü™ù Hook', 'üß© Component', '‚öôÔ∏è Service', 'üìù Full Example']}>
  <Tab value="ü™ù Hook">
```tsx title="hooks/use-users.ts"
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userService } from '@/features/users/services/user-service';
import type { User, CreateUserInput } from '@/features/users/types';

export function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: userService.getAll,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: ['users', id],
    queryFn: () => userService.getById(id),
    enabled: !!id, // Only fetch if id exists
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: userService.create,
    onSuccess: () => {
      // Invalidate the users list to refetch
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}
```
</Tab>
  <Tab value="üß© Component">
```tsx title="components/UserList.tsx"
'use client';

import { useUsers } from '@/features/users/hooks/use-users';
import { UserCard } from './UserCard';
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription } from '@/components/ui/alert';

export function UserList() {
  const { data: users, isLoading, isError, error } = useUsers();

if (isLoading) {
return (

<div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
{[...Array(6)].map((\_, i) => (
<Skeleton key={i} className="h-32 rounded-lg" />
))}
</div>
);
}

if (isError) {
return (

<Alert variant="destructive">
  <AlertDescription>Failed to load users: {error.message}</AlertDescription>
</Alert>
); }

return (

<div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
  {users?.map((user) => (
    <UserCard key={user.id} user={user} />
  ))}
</div>
); }

````
</Tab>
  <Tab value="‚öôÔ∏è Service">
```tsx title="services/user-service.ts"
import { api } from '@/lib/api';
import type { User, CreateUserInput, UpdateUserInput } from '../types';

export const userService = {
  async getAll(): Promise<User[]> {
    const response = await api.get('/users');
    return response.data;
  },

  async getById(id: string): Promise<User> {
    const response = await api.get(`/users/${id}`);
    return response.data;
  },

  async create(data: CreateUserInput): Promise<User> {
    const response = await api.post('/users', data);
    return response.data;
  },

  async update(id: string, data: UpdateUserInput): Promise<User> {
    const response = await api.patch(`/users/${id}`, data);
    return response.data;
  },

  async delete(id: string): Promise<void> {
    await api.delete(`/users/${id}`);
  },
};
````

</Tab>
  <Tab value="üìù Full Example">
```tsx title="Complete Data Flow Example"
// 1. Types (features/users/types/index.ts)
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
  avatar?: string;
  createdAt: string;
}

export interface CreateUserInput {
  name: string;
  email: string;
  role: User["role"];
}

// 2. Page Component (app/(dashboard)/users/page.tsx)
import { Suspense } from 'react';
import { UserList } from '@/features/users/components/UserList';
import { CreateUserButton } from '@/features/users/components/CreateUserButton';

export default function UsersPage() {
  return (
    <div className="container py-8">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold">Users</h1>
        <CreateUserButton />
      </div>
      
      <Suspense fallback={<UserListSkeleton />}>
        <UserList />
      </Suspense>
    </div>
  );
}
```
</Tab>
</Tabs>

---

### Example 3: Form with Validation

Forms are critical. Here's our pattern with React Hook Form + Zod.

<Tabs items={['üìã Schema', 'üß© Form Component', 'üöÄ Usage']}>
  <Tab value="üìã Schema">
```tsx title="validations/user-schema.ts"
import { z } from 'zod';

export const userSchema = z.object({
  name: z
    .string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be less than 50 characters'),
  
  email: z
    .string()
    .email('Please enter a valid email address'),
  
  role: z.enum(['admin', 'user', 'guest'], {
    errorMap: () => ({ message: 'Please select a valid role' }),
  }),
  
  bio: z
    .string()
    .max(500, 'Bio must be less than 500 characters')
    .optional(),
  
  notifications: z.object({
    email: z.boolean(),
    push: z.boolean(),
    sms: z.boolean(),
  }),
});

export type UserFormData = z.infer<typeof userSchema>;
```
</Tab>
  <Tab value="üß© Form Component">
```tsx title="components/UserForm.tsx"
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userSchema, type UserFormData } from '../validations/user-schema';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';

interface UserFormProps {
onSubmit: (data: UserFormData) => void;
defaultValues?: Partial<UserFormData>;
isLoading?: boolean;
}

export function UserForm({ onSubmit, defaultValues, isLoading }: UserFormProps) {
  const form = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: '',
      email: '',
      role: 'user',
      bio: '',
      notifications: {
        email: true,
        push: false,
        sms: false,
      },
      ...defaultValues,
    },
  });

return (

<Form {...form}>
<form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
<FormField
control={form.control}
name="name"
render={({ field }) => (
<FormItem>
<FormLabel>Name</FormLabel>
<FormControl>
<Input placeholder="John Doe" {...field} />
</FormControl>
<FormMessage />
</FormItem>
)}
/>

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" placeholder="john@example.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="role"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Role</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a role" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="admin">Admin</SelectItem>
                  <SelectItem value="user">User</SelectItem>
                  <SelectItem value="guest">Guest</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Saving...' : 'Save User'}
        </Button>
      </form>
    </Form>

);
}

````
</Tab>
  <Tab value="üöÄ Usage">
```tsx title="Using the Form"
'use client';

import { UserForm } from './UserForm';
import { useCreateUser } from '../hooks/use-users';
import { toast } from 'sonner';

export function CreateUserDialog() {
  const createUser = useCreateUser();

  const handleSubmit = async (data: UserFormData) => {
    try {
      await createUser.mutateAsync(data);
      toast.success('User created successfully!');
    } catch (error) {
      toast.error('Failed to create user');
    }
  };

  return (
    <UserForm
      onSubmit={handleSubmit}
      isLoading={createUser.isPending}
    />
  );
}
````

</Tab>
</Tabs>

---

## üéØ Practice Challenges

<Cards>
  <Card
    title="üî∞ Beginner: Todo App"
    description="Build a todo list with add, remove, and toggle complete functionality"
  />
  <Card
    title="üî∑ Intermediate: Data Table"
    description="Create a sortable, filterable table with pagination"
  />
  <Card
    title="üî∂ Advanced: Real-time Chat"
    description="Build a chat interface with WebSocket support and optimistic updates"
  />
  <Card
    title="‚≠ê Expert: Dashboard"
    description="Full dashboard with charts, data fetching, and responsive design"
  />
</Cards>

### Challenge: Build a Todo App

<Steps>
  <Step>
    ### Create the Types Define your `Todo` interface with `id`, `title`,
    `completed`, and `createdAt` fields.
  </Step>
  <Step>
    ### Build the State Management Use `useState` to manage an array of todos.
    Create `addTodo`, `removeTodo`, and `toggleTodo` functions.
  </Step>
  <Step>
    ### Create the UI Components Build `TodoItem`, `TodoList`, and `AddTodoForm`
    components.
  </Step>
  <Step>
    ### Add Persistence Save todos to localStorage and restore on page load
    using `useEffect`.
  </Step>
</Steps>

<Callout type="tip">
  **Pro Tip:** Start with the simplest working version, then iterate. Don't try
  to build everything at once!
</Callout>

---

## üìã Copy-Paste Recipes

### Loading States

```tsx title="Skeleton Pattern"
function UserCardSkeleton() {
  return (
    <Card className="p-4">
      <div className="flex items-center gap-4">
        <Skeleton className="h-12 w-12 rounded-full" />
        <div className="space-y-2">
          <Skeleton className="h-4 w-32" />
          <Skeleton className="h-3 w-24" />
        </div>
      </div>
    </Card>
  );
}
```

### ‚ö†Ô∏è Error Boundary

```tsx title="Error Boundary Pattern"
"use client";

import { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div className="p-4 bg-red-50 rounded-lg">
            <h2 className="text-red-800 font-bold">Something went wrong</h2>
            <p className="text-red-600">{this.state.error?.message}</p>
          </div>
        )
      );
    }

    return this.props.children;
  }
}
```

### üîç Debounced Search

```tsx title="Debounced Search Hook"
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [search, setSearch] = useState("");
  const debouncedSearch = useDebounce(search, 300);

  useEffect(() => {
    if (debouncedSearch) {
      // Fetch search results
    }
  }, [debouncedSearch]);

  return <Input value={search} onChange={(e) => setSearch(e.target.value)} />;
}
```

---

## üåê External Playgrounds

<Cards>
  <Card
    title="üîó CodeSandbox Templates"
    href="https://codesandbox.io"
    description="Ready-to-use templates for React, Next.js, and more"
  />
  <Card
    title="üîó StackBlitz"
    href="https://stackblitz.com"
    description="Instant dev environments in the browser"
  />
  <Card
    title="üîó React Playground"
    href="https://react.dev/learn"
    description="Official React interactive tutorials"
  />
</Cards>
