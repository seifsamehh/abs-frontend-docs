---
title: "Tutorial: Data Fetching Basics"
description: Learn to fetch, display, and manage data from APIs using TanStack Query
difficulty: beginner
estimatedTime: "40 min"
keywords: ["data-fetching", "tanstack-query", "api", "async", "tutorial"]
---

import { Callout } from "fumadocs-ui/components/callout";
import { Steps, Step } from "fumadocs-ui/components/steps";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# Tutorial: Data Fetching Basics

<Callout type="info">
  In this tutorial, you'll build a user list that fetches data from an API.
  You'll learn how to handle loading states, errors, and caching with TanStack
  Query.
</Callout>

## What We're Building

A user list component that:

- Fetches data from an API
- Shows loading and error states
- Caches data for better performance
- Refreshes data when needed

**Time:** ~40 minutes | **Level:** Beginner | **Prerequisites:** [Your First Component](/docs/tutorials/your-first-component)

---

## Step 1: Set Up TanStack Query

<Steps>
<Step>
### Install the package

```bash
pnpm add @tanstack/react-query
```

</Step>

<Step>
### Add the provider

TanStack Query needs a provider at the root of your app. Update your layout:

```tsx
// src/app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState } from "react";

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
```

```tsx
// src/app/layout.tsx
import { Providers } from "./providers";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

</Step>
</Steps>

---

## Step 2: Create a Data Fetching Function

<Steps>
<Step>
### Define the data type

```tsx
// src/types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  company: {
    name: string;
  };
}
```

</Step>

<Step>
### Create the fetch function

```tsx
// src/lib/api.ts
import type { User } from "@/types/user";

export async function fetchUsers(): Promise<User[]> {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");

  if (!response.ok) {
    throw new Error("Failed to fetch users");
  }

  return response.json();
}
```

<Callout type="note">
  We throw an error if the response isn't OK. TanStack Query will catch this and show it as an error state.
</Callout>
</Step>
</Steps>

---

## Step 3: Use the Query Hook

<Steps>
<Step>
### Create the UserList component

```tsx
// src/components/UserList.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "@/lib/api";

export function UserList() {
  const {
    data: users,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  if (isLoading) {
    return <div className="p-4">Loading users...</div>;
  }

  if (error) {
    return (
      <div className="p-4 text-red-500">
        Error: {error instanceof Error ? error.message : "Something went wrong"}
      </div>
    );
  }

  return (
    <div className="p-4">
      <h2 className="text-2xl font-bold mb-4">Users</h2>
      <ul className="space-y-2">
        {users?.map((user) => (
          <li key={user.id} className="p-3 bg-white rounded-lg shadow">
            <p className="font-medium">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
            <p className="text-sm text-gray-500">{user.company.name}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Key concepts:**

- `queryKey: ["users"]` - unique identifier for this data (used for caching)
- `queryFn` - the function that fetches data
- `isLoading` - true while data is being fetched
- `error` - contains any error that occurred
- `data` - the fetched data (renamed to `users`)

</Step>
</Steps>

---

## Step 4: Add a Refresh Button

TanStack Query makes refetching easy:

```tsx
export function UserList() {
  const {
    data: users,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  // ... loading and error states ...

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold">Users</h2>
        <button
          onClick={() => refetch()}
          disabled={isFetching}
          className="px-4 py-2 bg-primary text-white rounded-md disabled:opacity-50"
        >
          {isFetching ? "Refreshing..." : "Refresh"}
        </button>
      </div>
      {/* user list */}
    </div>
  );
}
```

- `refetch` - function to manually refetch
- `isFetching` - true during any fetch (initial or refetch)

---

## Step 5: Configure Caching

TanStack Query caches data automatically. You can configure when it refetches:

```tsx
const {
  data: users,
  isLoading,
  error,
} = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  staleTime: 5 * 60 * 1000, // Data is "fresh" for 5 minutes
  gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
});
```

<Callout type="tip">
  **Stale vs Cached:** - `staleTime` - how long until data is considered
  outdated - `gcTime` - how long to keep data in cache (previously called
  `cacheTime`) Fresh data won't refetch. Stale data will refetch in the
  background when accessed.
</Callout>

---

## Final Code

```tsx
"use client";

import { useQuery } from "@tanstack/react-query";

interface User {
  id: number;
  name: string;
  email: string;
  company: { name: string };
}

async function fetchUsers(): Promise<User[]> {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  if (!response.ok) throw new Error("Failed to fetch users");
  return response.json();
}

export function UserList() {
  const {
    data: users,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    staleTime: 5 * 60 * 1000,
  });

  if (isLoading) {
    return (
      <div className="p-4 flex items-center gap-2">
        <div className="animate-spin h-5 w-5 border-2 border-primary border-t-transparent rounded-full" />
        Loading users...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 bg-red-50 text-red-500 rounded-lg">
        Error: {error instanceof Error ? error.message : "Something went wrong"}
        <button onClick={() => refetch()} className="ml-2 underline">
          Try again
        </button>
      </div>
    );
  }

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold">Users ({users?.length})</h2>
        <button
          onClick={() => refetch()}
          disabled={isFetching}
          className="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary/90 disabled:opacity-50"
        >
          {isFetching ? "Refreshing..." : "Refresh"}
        </button>
      </div>
      <ul className="space-y-2">
        {users?.map((user) => (
          <li
            key={user.id}
            className="p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow"
          >
            <p className="font-medium text-gray-900">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
            <p className="text-xs text-gray-500 mt-1">{user.company.name}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## What You Learned

✅ **TanStack Query** manages server state with built-in caching  
✅ **useQuery** hook handles loading, error, and success states  
✅ **queryKey** identifies data for caching and refetching  
✅ **staleTime** controls when data is considered outdated  
✅ **refetch** lets users manually refresh data

---

## Next Steps

- **Practice:** [Interactive Examples](/docs/tutorials/interactive-examples) with data fetching
- **How-to:** [Fetching Data](/docs/how-to/data/fetching-data) for advanced patterns
- **Explanation:** [Why TanStack Query](/docs/explanation/decisions/adr-001-tanstack-query)
