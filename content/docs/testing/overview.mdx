---
title: Testing Overview
description: Comprehensive testing strategy and best practices for frontend applications
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# üß™ Testing Strategy

<Callout type="info">
  Our testing strategy ensures high-quality, reliable applications through
  comprehensive testing at multiple levels. We follow the testing pyramid
  approach with a focus on unit tests, supported by integration and end-to-end
  tests.
</Callout>

## üèóÔ∏è Testing Pyramid

<Cards>
  <Card
    title="üî¨ Unit Tests (70%)"
    description="Test individual functions and components in isolation"
    href="/docs/testing/unit-testing"
  />
  <Card
    title="üîó Integration Tests (20%)"
    description="Test component interactions and API integrations"
    href="/docs/testing/integration-testing"
  />
  <Card
    title="üé≠ E2E Tests (10%)"
    description="Test complete user workflows and critical paths"
    href="/docs/testing/e2e-testing"
  />
</Cards>

## üõ†Ô∏è Testing Tools

### Core Testing Framework

<Tabs items={["Vitest", "Testing Library", "Playwright", "MSW"]}>
  <Tab value="Vitest">
    - **Fast** - Vite-powered test runner - **Compatible** - Jest-compatible API
    - **TypeScript** - Native TypeScript support - **Watch Mode** - Fast
    feedback during development
  </Tab>
  <Tab value="Testing Library">
    - **User-Centric** - Test from user perspective - **Accessible** - Built-in
    accessibility testing - **Framework Agnostic** - Works with React, Vue,
    Angular - **Best Practices** - Encourages good testing practices
  </Tab>
  <Tab value="Playwright">
    - **Cross-Browser** - Chrome, Firefox, Safari, Edge - **Fast** - Parallel
    test execution - **Reliable** - Auto-wait and retry mechanisms -
    **Debugging** - Excellent debugging tools
  </Tab>
  <Tab value="MSW">
    - **API Mocking** - Mock API calls at network level - **Realistic** - Use
    real request/response patterns - **Development** - Use same mocks in dev and
    tests - **TypeScript** - Full type safety
  </Tab>
</Tabs>

## üìä Coverage Requirements

### Minimum Coverage Targets

- **Overall Coverage**: 80% minimum
- **Critical Paths**: 100% coverage (auth, payments, data mutations)
- **New Features**: Must include tests before merging
- **Bug Fixes**: Must include regression tests

### Coverage Reports

```bash
# Generate coverage report
npm run test:coverage

# Coverage with watch mode
npm run test:coverage:watch

# Coverage for specific files
npm run test:coverage -- --include="src/components/**"
```

## üéØ Testing Principles

### 1. **Test Behavior, Not Implementation**

Focus on what the user sees and does, not internal implementation details:

```tsx
// Good: Test behavior
test("displays user name when user is loaded", () => {
  render(<UserProfile userId="123" />);
  expect(screen.getByText("John Doe")).toBeInTheDocument();
});

// Avoid: Test implementation
test("calls fetchUser with correct id", () => {
  const fetchUser = vi.fn();
  render(<UserProfile userId="123" />);
  expect(fetchUser).toHaveBeenCalledWith("123");
});
```

### 2. **Write Tests That Matter**

Focus on testing critical functionality and user-facing features:

```tsx
// Good: Test critical functionality
test("prevents form submission with invalid email", async () => {
  render(<ContactForm />);

  await user.type(screen.getByLabelText("Email"), "invalid-email");
  await user.click(screen.getByRole("button", { name: "Submit" }));

  expect(screen.getByText("Please enter a valid email")).toBeInTheDocument();
  expect(screen.queryByText("Message sent!")).not.toBeInTheDocument();
});

// Avoid: Test trivial functionality
test("renders submit button", () => {
  render(<ContactForm />);
  expect(screen.getByRole("button", { name: "Submit" })).toBeInTheDocument();
});
```

### 3. **Keep Tests Simple and Readable**

Write tests that are easy to understand and maintain:

```tsx
// Good: Simple and clear
test("shows loading state while fetching data", () => {
  render(<UserList />);
  expect(screen.getByText("Loading...")).toBeInTheDocument();
});

// Avoid: Complex and hard to understand
test("renders user list with proper state management", () => {
  const mockStore = createMockStore({
    users: { data: [], loading: true, error: null },
    ui: { theme: "light", sidebar: { open: false } },
  });

  render(
    <Provider store={mockStore}>
      <UserList />
    </Provider>
  );

  expect(screen.getByTestId("user-list-container")).toHaveClass("loading");
  expect(screen.getByTestId("loading-spinner")).toBeInTheDocument();
});
```

## üî¨ Unit Testing

### Component Testing

```tsx
import { render, screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Button } from "./Button";

describe("Button", () => {
  it("renders with correct text", () => {
    render(<Button>Click me</Button>);
    expect(
      screen.getByRole("button", { name: "Click me" })
    ).toBeInTheDocument();
  });

  it("calls onClick when clicked", async () => {
    const user = userEvent.setup();
    const handleClick = vi.fn();

    render(<Button onClick={handleClick}>Click me</Button>);

    await user.click(screen.getByRole("button"));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it("is disabled when disabled prop is true", () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole("button")).toBeDisabled();
  });

  it("applies correct variant styles", () => {
    render(<Button variant="primary">Click me</Button>);
    expect(screen.getByRole("button")).toHaveClass("bg-primary");
  });
});
```

### Hook Testing

```tsx
import { renderHook, act } from "@testing-library/react";
import { useCounter } from "./useCounter";

describe("useCounter", () => {
  it("initializes with default value", () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it("increments counter", () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  it("decrements counter", () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(4);
  });
});
```

### Utility Function Testing

```tsx
import { formatCurrency, validateEmail } from "./utils";

describe("formatCurrency", () => {
  it("formats positive numbers correctly", () => {
    expect(formatCurrency(1234.56)).toBe("$1,234.56");
  });

  it("formats negative numbers correctly", () => {
    expect(formatCurrency(-1234.56)).toBe("-$1,234.56");
  });

  it("handles zero", () => {
    expect(formatCurrency(0)).toBe("$0.00");
  });
});

describe("validateEmail", () => {
  it("validates correct email addresses", () => {
    expect(validateEmail("test@example.com")).toBe(true);
    expect(validateEmail("user.name@domain.co.uk")).toBe(true);
  });

  it("rejects invalid email addresses", () => {
    expect(validateEmail("invalid-email")).toBe(false);
    expect(validateEmail("@domain.com")).toBe(false);
    expect(validateEmail("user@")).toBe(false);
  });
});
```

## üîó Integration Testing

### Component Integration

```tsx
import { render, screen, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { UserProfile } from "./UserProfile";

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe("UserProfile Integration", () => {
  it("loads and displays user data", async () => {
    // Mock API response
    global.fetch = vi.fn().mockResolvedValueOnce({
      ok: true,
      json: () =>
        Promise.resolve({
          id: "123",
          name: "John Doe",
          email: "john@example.com",
        }),
    });

    render(<UserProfile userId="123" />, { wrapper: createWrapper() });

    expect(screen.getByText("Loading...")).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    expect(screen.getByText("john@example.com")).toBeInTheDocument();
  });

  it("handles API errors gracefully", async () => {
    global.fetch = vi.fn().mockRejectedValueOnce(new Error("API Error"));

    render(<UserProfile userId="123" />, { wrapper: createWrapper() });

    await waitFor(() => {
      expect(screen.getByText("Error: API Error")).toBeInTheDocument();
    });
  });
});
```

### Form Integration

```tsx
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ContactForm } from "./ContactForm";

describe("ContactForm Integration", () => {
  it("submits form with valid data", async () => {
    const user = userEvent.setup();
    const mockSubmit = vi.fn();

    render(<ContactForm onSubmit={mockSubmit} />);

    await user.type(screen.getByLabelText("Name"), "John Doe");
    await user.type(screen.getByLabelText("Email"), "john@example.com");
    await user.type(screen.getByLabelText("Message"), "Hello, world!");

    await user.click(screen.getByRole("button", { name: "Submit" }));

    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        name: "John Doe",
        email: "john@example.com",
        message: "Hello, world!",
      });
    });
  });

  it("shows validation errors for invalid data", async () => {
    const user = userEvent.setup();
    render(<ContactForm onSubmit={vi.fn()} />);

    await user.click(screen.getByRole("button", { name: "Submit" }));

    expect(screen.getByText("Name is required")).toBeInTheDocument();
    expect(screen.getByText("Email is required")).toBeInTheDocument();
    expect(screen.getByText("Message is required")).toBeInTheDocument();
  });
});
```

## üé≠ End-to-End Testing

### Critical User Flows

```tsx
import { test, expect } from "@playwright/test";

test.describe("User Authentication Flow", () => {
  test("user can login and access dashboard", async ({ page }) => {
    // Navigate to login page
    await page.goto("/login");

    // Fill login form
    await page.fill('[data-testid="email-input"]', "user@example.com");
    await page.fill('[data-testid="password-input"]', "password123");

    // Submit form
    await page.click('[data-testid="login-button"]');

    // Wait for redirect to dashboard
    await expect(page).toHaveURL("/dashboard");

    // Verify dashboard content
    await expect(page.getByText("Welcome back!")).toBeVisible();
    await expect(page.getByText("Dashboard")).toBeVisible();
  });

  test("user can logout", async ({ page }) => {
    // Login first
    await page.goto("/login");
    await page.fill('[data-testid="email-input"]', "user@example.com");
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Wait for dashboard
    await expect(page).toHaveURL("/dashboard");

    // Click logout
    await page.click('[data-testid="logout-button"]');

    // Verify redirect to login
    await expect(page).toHaveURL("/login");
  });
});

test.describe("Shopping Cart Flow", () => {
  test("user can add item to cart and checkout", async ({ page }) => {
    // Navigate to product page
    await page.goto("/products/123");

    // Add item to cart
    await page.click('[data-testid="add-to-cart-button"]');

    // Verify cart count updates
    await expect(page.getByTestId("cart-count")).toHaveText("1");

    // Go to cart
    await page.click('[data-testid="cart-button"]');
    await expect(page).toHaveURL("/cart");

    // Proceed to checkout
    await page.click('[data-testid="checkout-button"]');
    await expect(page).toHaveURL("/checkout");

    // Fill checkout form
    await page.fill('[data-testid="name-input"]', "John Doe");
    await page.fill('[data-testid="email-input"]', "john@example.com");
    await page.fill('[data-testid="address-input"]', "123 Main St");

    // Complete purchase
    await page.click('[data-testid="place-order-button"]');

    // Verify success message
    await expect(page.getByText("Order placed successfully!")).toBeVisible();
  });
});
```

## ‚ôø Accessibility Testing

### Automated Accessibility Testing

```tsx
import { render } from "@testing-library/react";
import { axe, toHaveNoViolations } from "jest-axe";
import { Button } from "./Button";

expect.extend(toHaveNoViolations);

describe("Button Accessibility", () => {
  it("should not have accessibility violations", async () => {
    const { container } = render(<Button>Click me</Button>);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it("should be keyboard accessible", () => {
    render(<Button>Click me</Button>);
    const button = screen.getByRole("button");

    // Focus should be possible
    button.focus();
    expect(button).toHaveFocus();

    // Should be clickable with Enter key
    fireEvent.keyDown(button, { key: "Enter", code: "Enter" });
    expect(button).toHaveBeenCalled();
  });
});
```

### Manual Accessibility Testing

```tsx
describe("Accessibility Manual Tests", () => {
  it("should be navigable with keyboard only", async () => {
    render(<Navigation />);

    // Tab through navigation items
    const firstItem = screen.getByRole("link", { name: "Home" });
    firstItem.focus();
    expect(firstItem).toHaveFocus();

    // Arrow keys should navigate between items
    fireEvent.keyDown(firstItem, { key: "ArrowRight" });
    const secondItem = screen.getByRole("link", { name: "About" });
    expect(secondItem).toHaveFocus();
  });

  it("should announce changes to screen readers", () => {
    render(<NotificationSystem />);

    // Trigger notification
    fireEvent.click(screen.getByRole("button", { name: "Show notification" }));

    // Check for live region announcement
    const liveRegion = screen.getByRole("status");
    expect(liveRegion).toHaveTextContent("Notification: Success message");
  });
});
```

## ‚ö° Performance Testing

### Component Performance

```tsx
import { render } from "@testing-library/react";
import { measurePerformance } from "@testing-library/react-hooks";
import { HeavyComponent } from "./HeavyComponent";

describe("HeavyComponent Performance", () => {
  it("should render within performance budget", async () => {
    const { result } = await measurePerformance(() => {
      return render(<HeavyComponent data={largeDataset} />);
    });

    expect(result.renderTime).toBeLessThan(100); // 100ms
    expect(result.memoryUsage).toBeLessThan(50 * 1024 * 1024); // 50MB
  });

  it("should not cause memory leaks", () => {
    const { unmount } = render(<HeavyComponent data={largeDataset} />);

    // Unmount component
    unmount();

    // Force garbage collection
    global.gc?.();

    // Check memory usage hasn't increased significantly
    expect(process.memoryUsage().heapUsed).toBeLessThan(
      initialMemoryUsage * 1.1
    );
  });
});
```

### Bundle Size Testing

```tsx
import { analyzeBundle } from "./bundle-analyzer";

describe("Bundle Size", () => {
  it("should not exceed size limits", () => {
    const bundleStats = analyzeBundle();

    expect(bundleStats.totalSize).toBeLessThan(500 * 1024); // 500KB
    expect(bundleStats.chunkSizes.main).toBeLessThan(200 * 1024); // 200KB
    expect(bundleStats.chunkSizes.vendor).toBeLessThan(300 * 1024); // 300KB
  });

  it("should not have duplicate dependencies", () => {
    const bundleStats = analyzeBundle();

    expect(bundleStats.duplicates).toHaveLength(0);
  });
});
```

## üöÄ Testing Best Practices

<Callout type="tip">Follow these best practices for effective testing:</Callout>

### 1. **Test Early and Often**

- Write tests as you develop features
- Run tests frequently during development
- Fix failing tests immediately

### 2. **Keep Tests Fast**

- Use unit tests for most testing
- Mock external dependencies
- Avoid unnecessary DOM operations

### 3. **Make Tests Reliable**

- Avoid flaky tests
- Use proper waiting strategies
- Mock time-dependent code

### 4. **Write Clear Tests**

- Use descriptive test names
- Keep tests focused and simple
- Add comments for complex scenarios

### 5. **Maintain Test Coverage**

- Monitor coverage metrics
- Focus on critical paths
- Remove obsolete tests

## üîß Testing Configuration

### Vitest Configuration

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    setupFiles: ["./src/test/setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules/", "src/test/", "**/*.d.ts", "**/*.config.*"],
    },
  },
});
```

### Playwright Configuration

```typescript
// playwright.config.ts
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./tests/e2e",
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: "html",
  use: {
    baseURL: "http://localhost:3000",
    trace: "on-first-retry",
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
    {
      name: "firefox",
      use: { ...devices["Desktop Firefox"] },
    },
    {
      name: "webkit",
      use: { ...devices["Desktop Safari"] },
    },
  ],
});
```

## üìä Testing Metrics

### Key Metrics to Track

- **Test Coverage**: Percentage of code covered by tests
- **Test Execution Time**: How long tests take to run
- **Test Reliability**: Percentage of tests that pass consistently
- **Bug Detection Rate**: How many bugs are caught by tests
- **Test Maintenance Cost**: Time spent maintaining tests

### Monitoring and Reporting

```bash
# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch

# Run E2E tests
npm run test:e2e

# Run all tests
npm run test:all
```

<Callout type="note">
  Remember: Good tests are an investment in code quality and team productivity.
  They help catch bugs early, enable confident refactoring, and serve as living
  documentation.
</Callout>
