---
title: Best Practices
description: Industry-leading best practices for modern frontend development
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# ‚ú® Best Practices

<Callout type="info">
  These best practices represent our commitment to excellence in frontend
  development, combining industry standards with lessons learned from real-world
  projects.
</Callout>

## React Best Practices

### Component Design Principles

<Cards>
  <Card
    title="üîÅ Single Responsibility"
    description="Each component should have one clear purpose"
  />
  <Card
    title="üì¶ Composition over Inheritance"
    description="Build complex UIs through component composition"
  />
  <Card
    title="üîí Immutability"
    description="Avoid mutating props and state directly"
  />
  <Card
    title="üéØ Props Interface Design"
    description="Clear, typed, and minimal prop interfaces"
  />
</Cards>

#### Example: Well-Designed Component

```tsx
interface ButtonProps {
  variant?: "primary" | "secondary" | "danger";
  size?: "sm" | "md" | "lg";
  isLoading?: boolean;
  disabled?: boolean;
  children: ReactNode;
  onClick?: () => void;
}

const Button: FC<ButtonProps> = ({
  variant = "primary",
  size = "md",
  isLoading = false,
  disabled = false,
  children,
  onClick,
  ...props
}) => {
  const baseClasses =
    "inline-flex items-center justify-center font-medium rounded-md";
  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
    danger: "bg-red-600 text-white hover:bg-red-700",
  };
  const sizeClasses = {
    sm: "px-3 py-1.5 text-sm",
    md: "px-4 py-2 text-base",
    lg: "px-6 py-3 text-lg",
  };

  return (
    <button
      className={cn(
        baseClasses,
        variantClasses[variant],
        sizeClasses[size],
        (disabled || isLoading) && "opacity-50 cursor-not-allowed"
      )}
      disabled={disabled || isLoading}
      onClick={onClick}
      {...props}
    >
      {isLoading && <Spinner className="mr-2" />}
      {children}
    </button>
  );
};
```

### State Management Best Practices

<Tabs items={['Local State', 'Context API', 'External State']}>
  <Tab value="Local State">
    ```tsx
    // Use local state for component-specific data
    const SearchInput: FC = () => {
      const [query, setQuery] = useState('');
      const [isSearching, setIsSearching] = useState(false);

      const handleSearch = useMemo(() =>
        debounce(async (searchQuery: string) => {
          setIsSearching(true);
          try {
            const results = await searchApi(searchQuery);
            setResults(results);
          } finally {
            setIsSearching(false);
          }
        }, 300),
        []
      );

      useEffect(() => {
        if (query.length > 2) {
          handleSearch(query);
        }
      }, [query, handleSearch]);

      return (
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search..."
        />
      );
    };
    ```

  </Tab>
  <Tab value="Context API">
    ```tsx
    // Use Context for theme, user data, or app-wide state
    interface ThemeContextValue {
      theme: 'light' | 'dark';
      toggleTheme: () => void;
    }

    const ThemeContext = createContext<ThemeContextValue | null>(null);

    export const ThemeProvider: FC<{ children: ReactNode }> = ({ children }) => {
      const [theme, setTheme] = useState<'light' | 'dark'>('light');

      const toggleTheme = useCallback(() => {
        setTheme(prev => prev === 'light' ? 'dark' : 'light');
      }, []);

      const value = useMemo(() => ({
        theme,
        toggleTheme,
      }), [theme, toggleTheme]);

      return (
        <ThemeContext.Provider value={value}>
          <div data-theme={theme}>
            {children}
          </div>
        </ThemeContext.Provider>
      );
    };

    export const useTheme = (): ThemeContextValue => {
      const context = useContext(ThemeContext);
      if (!context) {
        throw new Error('useTheme must be used within ThemeProvider');
      }
      return context;
    };
    ```

  </Tab>
  <Tab value="External State">
    ```tsx
    // Use Redux Toolkit for complex state management
    import { createSlice, PayloadAction, configureStore } from '@reduxjs/toolkit';
    import { useDispatch, useSelector } from 'react-redux';

    interface Todo {
      id: string;
      text: string;
      completed: boolean;
    }

    interface TodosState {
      todos: Todo[];
    }

    const initialState: TodosState = {
      todos: [],
    };

    const todosSlice = createSlice({
      name: 'todos',
      initialState,
      reducers: {
        addTodo: (state, action: PayloadAction<string>) => {
          state.todos.push({
            id: crypto.randomUUID(),
            text: action.payload,
            completed: false,
          });
        },
        toggleTodo: (state, action: PayloadAction<string>) => {
          const todo = state.todos.find((t) => t.id === action.payload);
          if (todo) todo.completed = !todo.completed;
        },
        removeTodo: (state, action: PayloadAction<string>) => {
          state.todos = state.todos.filter((t) => t.id !== action.payload);
        },
      },
    });

    export const { addTodo, toggleTodo, removeTodo } = todosSlice.actions;

    const store = configureStore({
      reducer: {
        todos: todosSlice.reducer,
      },
    });

    // Usage in a component
    const TodoList: FC = () => {
      const dispatch = useDispatch();
      const todos = useSelector((state: any) => state.todos.todos);

      return (
        <div>
          <button onClick={() => dispatch(addTodo('New Task'))}>Add Todo</button>
          <ul>
            {todos.map((todo: Todo) => (
              <li key={todo.id}>
                <span
                  style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
                  onClick={() => dispatch(toggleTodo(todo.id))}
                >
                  {todo.text}
                </span>
                <button onClick={() => dispatch(removeTodo(todo.id))}>Remove</button>
              </li>
            ))}
          </ul>
        </div>
      );
    };
    ```

  </Tab>
</Tabs>

## Performance Optimization

### Code Splitting Strategies

```tsx
// Route-based code splitting
const Dashboard = lazy(() => import("./Dashboard"));
const Settings = lazy(() => import("./Settings"));

// Component-based code splitting
const HeavyChart = lazy(() =>
  import("./HeavyChart").then((module) => ({ default: module.Chart }))
);

// Conditional loading
const AdminPanel = lazy(() =>
  import("./AdminPanel").then((module) => {
    // Only load if user is admin
    if (!user.isAdmin) {
      return Promise.reject(new Error("Unauthorized"));
    }
    return { default: module.AdminPanel };
  })
);

// Usage with Suspense
<Suspense fallback={<LoadingSpinner />}>
  <HeavyChart data={chartData} />
</Suspense>;
```

### Memoization Best Practices

```tsx
// Memoize expensive calculations
const ExpensiveComponent: FC<{ items: Item[] }> = ({ items }) => {
  const expensiveValue = useMemo(() => {
    return items.reduce((acc, item) => {
      // Complex calculation
      return acc + calculateComplexValue(item);
    }, 0);
  }, [items]);

  const handleItemClick = useCallback(
    (id: string) => {
      // Handle click logic
      onItemClick(id);
    },
    [onItemClick]
  );

  return (
    <div>
      <p>Total: {expensiveValue}</p>
      {items.map((item) => (
        <Item key={item.id} item={item} onClick={handleItemClick} />
      ))}
    </div>
  );
};

// Memoize components to prevent unnecessary re-renders
const Item = memo<{ item: Item; onClick: (id: string) => void }>(
  ({ item, onClick }) => {
    return <div onClick={() => onClick(item.id)}>{item.name}</div>;
  }
);
```

## API Best Practices

### Error Handling Patterns

```typescript
// Result pattern for predictable error handling
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

class ApiClient {
  async get<T>(endpoint: string): Promise<Result<T>> {
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        headers: this.getHeaders(),
      });

      if (!response.ok) {
        const error = await this.parseError(response);
        return { success: false, error };
      }

      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error("Unknown error"),
      };
    }
  }

  private async parseError(response: Response): Promise<Error> {
    try {
      const errorData = await response.json();
      return new Error(errorData.message || `HTTP ${response.status}`);
    } catch {
      return new Error(`HTTP ${response.status} - ${response.statusText}`);
    }
  }
}

// Usage in React component
const UserProfile: FC<{ userId: string }> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadUser = async () => {
      setLoading(true);
      setError(null);

      const result = await apiClient.get<User>(`/users/${userId}`);

      if (result.success) {
        setUser(result.data);
      } else {
        setError(result.error.message);
      }

      setLoading(false);
    };

    loadUser();
  }, [userId]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!user) return <NotFound />;

  return <UserDetails user={user} />;
};
```

### Data Fetching with TanStack Query

```typescript
// Query key factory for consistency
const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// Custom hooks for data fetching
export const useUser = (userId: string) => {
  return useQuery({
    queryKey: userKeys.detail(userId),
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });
};

export const useUsers = (filters: UserFilters) => {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(filters)),
    queryFn: () => fetchUsers(filters),
    placeholderData: keepPreviousData,
  });
};

// Optimistic updates
export const useUpdateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateUser,
    onMutate: async (newUser) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({
        queryKey: userKeys.detail(newUser.id),
      });

      // Snapshot previous value
      const previousUser = queryClient.getQueryData(
        userKeys.detail(newUser.id)
      );

      // Optimistically update
      queryClient.setQueryData(userKeys.detail(newUser.id), newUser);

      return { previousUser };
    },
    onError: (err, newUser, context) => {
      // Rollback on error
      queryClient.setQueryData(
        userKeys.detail(newUser.id),
        context?.previousUser
      );
    },
    onSettled: (data, error, variables) => {
      // Refetch after mutation
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id),
      });
    },
  });
};
```

## Testing Best Practices

### Testing Pyramid Strategy

<Cards>
  <Card
    title="üî¨ Unit Tests (70%)"
    description="Test individual functions and components in isolation"
  />
  <Card
    title="üîó Integration Tests (20%)"
    description="Test component interactions and API integrations"
  />
  <Card title="üé≠ E2E Tests (10%)" description="Test complete user workflows" />
</Cards>

### Testing Examples

<Tabs items={['Component Testing', 'Hook Testing', 'API Testing']}>
  <Tab value="Component Testing">
    ```typescript
    import { render, screen, fireEvent, waitFor } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { Button } from './Button';

    describe('Button', () => {
      it('renders children correctly', () => {
        render(<Button>Click me</Button>);
        expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
      });

      it('calls onClick when clicked', async () => {
        const user = userEvent.setup();
        const handleClick = vi.fn();

        render(<Button onClick={handleClick}>Click me</Button>);

        await user.click(screen.getByRole('button'));
        expect(handleClick).toHaveBeenCalledTimes(1);
      });

      it('shows loading state correctly', () => {
        render(<Button isLoading>Loading</Button>);

        expect(screen.getByRole('button')).toBeDisabled();
        expect(screen.getByTestId('spinner')).toBeInTheDocument();
      });

      it('applies correct variant styles', () => {
        render(<Button variant="danger">Delete</Button>);

        expect(screen.getByRole('button')).toHaveClass('bg-red-600');
      });
    });
    ```

  </Tab>
  <Tab value="Hook Testing">
    ```typescript
    import { renderHook, act } from '@testing-library/react';
    import { useCounter } from './useCounter';

    describe('useCounter', () => {
      it('initializes with default value', () => {
        const { result } = renderHook(() => useCounter());
        expect(result.current.count).toBe(0);
      });

      it('initializes with custom value', () => {
        const { result } = renderHook(() => useCounter(5));
        expect(result.current.count).toBe(5);
      });

      it('increments count', () => {
        const { result } = renderHook(() => useCounter());

        act(() => {
          result.current.increment();
        });

        expect(result.current.count).toBe(1);
      });

      it('decrements count', () => {
        const { result } = renderHook(() => useCounter(5));

        act(() => {
          result.current.decrement();
        });

        expect(result.current.count).toBe(4);
      });
    });
    ```

  </Tab>
  <Tab value="API Testing">
    ```typescript
    import { rest } from 'msw';
    import { setupServer } from 'msw/node';
    import { render, screen, waitFor } from '@testing-library/react';
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import { UserProfile } from './UserProfile';

    const server = setupServer(
      rest.get('/api/users/:id', (req, res, ctx) => {
        const { id } = req.params;
        return res(
          ctx.json({
            id,
            name: 'John Doe',
            email: 'john@example.com'
          })
        );
      })
    );

    beforeAll(() => server.listen());
    afterEach(() => server.resetHandlers());
    afterAll(() => server.close());

    const createWrapper = () => {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: { retry: false },
          mutations: { retry: false },
        },
      });

      return ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      );
    };

    describe('UserProfile', () => {
      it('loads and displays user data', async () => {
        render(<UserProfile userId="123" />, { wrapper: createWrapper() });

        expect(screen.getByText('Loading...')).toBeInTheDocument();

        await waitFor(() => {
          expect(screen.getByText('John Doe')).toBeInTheDocument();
        });

        expect(screen.getByText('john@example.com')).toBeInTheDocument();
      });

      it('handles API errors gracefully', async () => {
        server.use(
          rest.get('/api/users/:id', (req, res, ctx) => {
            return res(ctx.status(404), ctx.json({ message: 'User not found' }));
          })
        );

        render(<UserProfile userId="999" />, { wrapper: createWrapper() });

        await waitFor(() => {
          expect(screen.getByText('Error: User not found')).toBeInTheDocument();
        });
      });
    });
    ```

  </Tab>
</Tabs>

## Accessibility Best Practices

### ARIA and Semantic HTML

```tsx
// Good: Semantic HTML with proper ARIA
const SearchForm: FC = () => {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  return (
    <form role="search" aria-label="Site search">
      <div>
        <label htmlFor="search-input" className="sr-only">
          Search
        </label>
        <input
          id="search-input"
          type="search"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search..."
          aria-describedby="search-help"
          aria-expanded={results.length > 0}
          aria-owns={results.length > 0 ? "search-results" : undefined}
        />
        <div id="search-help" className="sr-only">
          Type to search. Results will appear below.
        </div>
      </div>

      {isSearching && (
        <div aria-live="polite" aria-label="Searching...">
          <SearchSpinner />
        </div>
      )}

      {results.length > 0 && (
        <ul
          id="search-results"
          role="listbox"
          aria-label={`${results.length} search results`}
        >
          {results.map((result, index) => (
            <li
              key={result.id}
              role="option"
              aria-selected={false}
              tabIndex={-1}
            >
              <a href={result.url}>{result.title}</a>
            </li>
          ))}
        </ul>
      )}
    </form>
  );
};
```

### Focus Management

```tsx
const Modal: FC<{
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
}> = ({ isOpen, onClose, children }) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (isOpen) {
      // Store previous focus
      previousFocusRef.current = document.activeElement as HTMLElement;

      // Focus modal
      modalRef.current?.focus();

      // Prevent background scrolling
      document.body.style.overflow = "hidden";
    } else {
      // Restore previous focus
      previousFocusRef.current?.focus();

      // Restore scrolling
      document.body.style.overflow = "unset";
    }

    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === "Escape") {
      onClose();
    }

    // Trap focus within modal
    if (e.key === "Tab") {
      const focusableElements = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      if (!focusableElements?.length) return;

      const firstElement = focusableElements[0] as HTMLElement;
      const lastElement = focusableElements[
        focusableElements.length - 1
      ] as HTMLElement;

      if (e.shiftKey && document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 bg-black/50"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        tabIndex={-1}
        className="fixed inset-x-4 top-[50%] max-h-[85vh] translate-y-[-50%] rounded-lg bg-white p-6"
        onKeyDown={handleKeyDown}
      >
        {children}
      </div>
    </div>
  );
};
```

## Security Best Practices

### Input Validation and Sanitization

```typescript
import { z } from "zod";
import DOMPurify from "dompurify";

// Schema-based validation
const userSchema = z.object({
  email: z.string().email("Invalid email address"),
  name: z.string().min(2, "Name must be at least 2 characters"),
  age: z.number().min(0).max(120),
});

// Safe HTML rendering
const SafeHTML: FC<{ content: string }> = ({ content }) => {
  const sanitizedContent = useMemo(() => {
    return DOMPurify.sanitize(content, {
      ALLOWED_TAGS: ["p", "b", "i", "em", "strong", "a"],
      ALLOWED_ATTR: ["href"],
    });
  }, [content]);

  return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />;
};

// Environment variable validation
const config = {
  apiUrl: z.string().url().parse(process.env.NEXT_PUBLIC_API_URL),
  secretKey: z.string().min(32).parse(process.env.SECRET_KEY),
} as const;
```

<Callout type="warning">
  Always validate and sanitize user input, both on the client and server sides.
</Callout>

## Code Organization Best Practices

### Project Structure

```
project/
+-- üìÑ README.md                    # Project documentation
+-- üì¶ package.json                 # Dependencies & scripts
+-- ‚öôÔ∏è  next.config.ts              # Next.js configuration
+-- üé® tailwind.config.ts          # Tailwind CSS configuration
+-- üìù tsconfig.json               # TypeScript configuration
+-- üîç eslint.config.mjs           # ESLint rules
+-- üß© components.json             # Shadcn/ui configuration
+-- üé® postcss.config.mjs          # PostCSS plugins
+-- üåç middleware.ts               # Next.js middleware
+-- üìä metadata.ts                 # Site metadata
|
+-- üåê public/                     # Static assets
|   +-- üì± manifest.json           # PWA configuration
|   +-- üñºÔ∏è  assets/                 # Images, logos, icons
|   +-- üì± android/                # Android app icons
|   +-- üçé ios/                    # iOS app icons
|   +-- ü™ü windows11/              # Windows 11 icons
|
+-- üó£Ô∏è  messages/                   # Internationalization
|   +-- üá∫üá∏ en.json                # English translations
|   +-- üá∏üá¶ ar.json                # Arabic translations
|
+-- üìÇ src/                        # Source code
    +-- üö¶ app/                    # Next.js App Router
    +-- üß© components/             # Shared UI components
    +-- ‚ö° features/               # Feature modules
    +-- ü™ù hooks/                  # Custom React hooks
    +-- üîß lib/                    # Utilities & helpers
    +-- üåê i18n/                   # i18n configuration
    +-- üìù constants/              # Application constants          # Global styles and theme
```

### Import Organization

```typescript
// 1. React and third-party imports
import { useState, useEffect, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import { z } from "zod";

// 2. Internal imports (absolute paths)
import { Button } from "@/components/ui/button";
import { apiClient } from "@/lib/api";
import { userSchema } from "@/lib/validations";

// 3. Relative imports
import { UserCard } from "./user-card";
import { formatUserName } from "../utils";

// 4. Type-only imports (separate)
import type { User } from "@/types/user";
import type { FC } from "react";
```

This comprehensive guide ensures that our frontend development follows industry best practices while maintaining consistency across all projects. Remember to regularly review and update these practices as technology and requirements evolve.
