---
title: "ADR-001: TanStack Query for Server State"
description: Using TanStack Query for server state management
keywords:
  ["adr", "tanstack-query", "react-query", "state-management", "data-fetching"]
---

import { Callout } from "fumadocs-ui/components/callout";

# ADR-001: Use TanStack Query for Server State Management

## Status

✅ **Accepted** (June 2024)

## Context

We needed a robust solution for managing server state (data fetched from APIs) in our React applications. Key requirements:

- **Caching**: Avoid redundant API calls
- **Synchronization**: Keep UI in sync with server data
- **Loading/Error States**: Handle async states gracefully
- **Mutations**: Update server data and sync client state
- **DevTools**: Debug data flow easily
- **TypeScript**: Full type safety

### Options Considered

| Solution                    | Pros                                          | Cons                            |
| --------------------------- | --------------------------------------------- | ------------------------------- |
| **TanStack Query**          | Excellent caching, great DX, active community | Learning curve                  |
| **SWR**                     | Simple API, Vercel ecosystem                  | Less features than TanStack     |
| **Redux Toolkit Query**     | Integrates with Redux                         | Overkill if not using Redux     |
| **Manual fetch + useState** | No dependencies                               | Lots of boilerplate, no caching |

## Decision

We chose **TanStack Query** (formerly React Query) as our server state management solution.

### Key Reasons

1. **Best-in-class caching**: Automatic background refetching, stale-while-revalidate
2. **Excellent DevTools**: Visual inspection of queries and cache
3. **Mutation support**: Optimistic updates, automatic cache invalidation
4. **TypeScript-first**: Full type inference
5. **Framework agnostic**: Works with any fetching library
6. **Active ecosystem**: Well-maintained, large community

## Implementation

### Basic Setup

```typescript
// src/providers/query-provider.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            gcTime: 5 * 60 * 1000, // 5 minutes
            retry: 1,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### Query Hook Pattern

```typescript
// src/features/users/hooks/use-users.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { userService } from "../services/user-service";
import type { User, CreateUserInput } from "../types";

// Query keys factory
export const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: object) => [...userKeys.lists(), filters] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// List query
export function useUsers(filters?: object) {
  return useQuery({
    queryKey: userKeys.list(filters ?? {}),
    queryFn: () => userService.getUsers(filters),
  });
}

// Detail query
export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => userService.getUser(id),
    enabled: !!id,
  });
}

// Create mutation
export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateUserInput) => userService.createUser(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

## Consequences

### Positive

- ✅ **90% reduction** in data fetching boilerplate
- ✅ **Automatic caching** reduces API calls by ~60%
- ✅ **Better UX** with instant UI updates via optimistic updates
- ✅ **DevTools** make debugging much easier
- ✅ **Type safety** catches errors at compile time

### Negative

- ⚠️ **Learning curve** for developers new to TanStack Query
- ⚠️ **Bundle size** adds ~12KB gzipped
- ⚠️ **Query key management** requires discipline

### Neutral

- Teams need to distinguish between server state (TanStack Query) and client state (useState/Context)
- Requires defining query key factories for proper cache invalidation

## References

- [TanStack Query Documentation](https://tanstack.com/query)
- [Practical React Query](https://tkdodo.eu/blog/practical-react-query)
- [Query Keys Best Practices](https://tanstack.com/query/latest/docs/react/guides/query-keys)

<Callout type="info">
  This decision supersedes our previous approach of using Redux for all state
  management.
</Callout>
