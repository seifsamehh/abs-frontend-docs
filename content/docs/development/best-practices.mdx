---
title: Best Practices
description: Comprehensive best practices for performance, accessibility, and code quality in frontend development
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# ‚ú® Frontend Best Practices

<Callout type="info">
  These best practices represent our commitment to excellence in frontend
  development, combining industry standards with lessons learned from our
  production applications.
</Callout>

## ‚ö° Performance Best Practices

### Core Web Vitals Optimization

<Cards>
  <Card
    title="üöÄ LCP < 2.5s"
    description="Largest Contentful Paint optimization techniques"
  />
  <Card
    title="‚ö° FID < 100ms"
    description="First Input Delay and interaction responsiveness"
  />
  <Card title="üéØ CLS < 0.1" description="Cumulative Layout Shift prevention" />
  <Card
    title="üèÉ FCP < 1.8s"
    description="First Contentful Paint optimization"
  />
</Cards>

### Code Splitting Strategies

```tsx
// ‚úÖ Route-based code splitting
import { lazy, Suspense } from "react";

const Dashboard = lazy(() => import("./Dashboard"));
const Settings = lazy(() => import("./Settings"));

// ‚úÖ Component-based code splitting with error handling
const HeavyChart = lazy(() =>
  import("./HeavyChart")
    .then((module) => ({ default: module.Chart }))
    .catch(() => ({ default: () => <div>Failed to load chart</div> }))
);

// ‚úÖ Conditional loading based on user permissions
const AdminPanel = lazy(async () => {
  const { user } = await import("./auth");
  if (!user.isAdmin) {
    throw new Error("Unauthorized");
  }
  return import("./AdminPanel");
});

// ‚úÖ Usage with proper error boundaries
<ErrorBoundary fallback={<ChartError />}>
  <Suspense fallback={<ChartSkeleton />}>
    <HeavyChart data={chartData} />
  </Suspense>
</ErrorBoundary>;
```

### Image Optimization

```tsx
// ‚úÖ Next.js Image optimization
import Image from 'next/image';

// Static images
<Image
  src="/assets/hero-image.jpg"
  alt="Company hero image"
  width={1200}
  height={600}
  priority // For above-the-fold images
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
/>

// Dynamic images with proper sizing
<Image
  src={user.avatarUrl}
  alt={`${user.name}'s avatar`}
  width={40}
  height={40}
  className="rounded-full"
  sizes="(max-width: 768px) 32px, 40px"
/>

// Responsive images
<Image
  src="/assets/banner.jpg"
  alt="Promotional banner"
  fill
  className="object-cover"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```

### Memoization Best Practices

```tsx
// ‚úÖ Memoize expensive calculations
const ExpensiveComponent: FC<{ items: Item[] }> = ({ items }) => {
  const expensiveValue = useMemo(() => {
    return items.reduce((acc, item) => {
      // Complex calculation that should only run when items change
      return acc + calculateComplexValue(item);
    }, 0);
  }, [items]); // Only recalculate when items array changes

  const sortedItems = useMemo(() => {
    return [...items].sort((a, b) => a.priority - b.priority);
  }, [items]);

  const handleItemClick = useCallback(
    (id: string) => {
      // Stable function reference prevents child re-renders
      onItemClick(id);
    },
    [onItemClick]
  );

  return (
    <div>
      <p>Total: {expensiveValue}</p>
      {sortedItems.map((item) => (
        <MemoizedItem key={item.id} item={item} onClick={handleItemClick} />
      ))}
    </div>
  );
};

// ‚úÖ Memoize components to prevent unnecessary re-renders
const MemoizedItem = memo<{ item: Item; onClick: (id: string) => void }>(
  ({ item, onClick }) => {
    return (
      <div
        className="p-4 border rounded cursor-pointer hover:bg-gray-50"
        onClick={() => onClick(item.id)}
      >
        <h3>{item.name}</h3>
        <p>{item.description}</p>
      </div>
    );
  },
  // Custom comparison function for complex props
  (prevProps, nextProps) => {
    return (
      prevProps.item.id === nextProps.item.id &&
      prevProps.item.updatedAt === nextProps.item.updatedAt
    );
  }
);
```

### Bundle Optimization

```javascript
// ‚úÖ Next.js configuration for bundle optimization
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable webpack bundle analyzer in development
  webpack: (config, { dev, isServer }) => {
    if (dev && !isServer) {
      const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: "server",
          openAnalyzer: false,
        })
      );
    }
    return config;
  },

  // Optimize images
  images: {
    formats: ["image/avif", "image/webp"],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 days
  },

  // Enable experimental features
  experimental: {
    optimizeCss: true,
    gzipSize: true,
  },
};
```

## üé® React Best Practices

### Component Design Principles

<Tabs items={['Single Responsibility', 'Composition', 'Props Design', 'State Management']}>
  <Tab value="Single Responsibility">
    ```tsx
    // ‚ùå Component doing too many things
    const UserDashboard = () => {
      const [users, setUsers] = useState([]);
      const [selectedUser, setSelectedUser] = useState(null);
      const [isEditing, setIsEditing] = useState(false);
      const [notifications, setNotifications] = useState([]);
      
      // Too many responsibilities: fetching, displaying, editing, notifications
      // ... lots of complex logic
    };

    // ‚úÖ Break into focused components
    const UserDashboard = () => (
      <div className="dashboard">
        <NotificationCenter />
        <UserList onSelectUser={setSelectedUser} />
        {selectedUser && (
          <UserDetails
            user={selectedUser}
            onEdit={() => setIsEditing(true)}
          />
        )}
        {isEditing && (
          <UserEditModal
            user={selectedUser}
            onClose={() => setIsEditing(false)}
          />
        )}
      </div>
    );
    ```

  </Tab>
  <Tab value="Composition">
    ```tsx
    // ‚úÖ Flexible composition with children
    const Card = ({ children, className, ...props }) => (
      <div className={cn("rounded-lg border bg-card p-6", className)} {...props}>
        {children}
      </div>
    );

    const CardHeader = ({ children, className, ...props }) => (
      <div className={cn("flex flex-col space-y-1.5 pb-6", className)} {...props}>
        {children}
      </div>
    );

    const CardContent = ({ children, className, ...props }) => (
      <div className={cn("pt-0", className)} {...props}>
        {children}
      </div>
    );

    // Usage - highly composable
    <Card>
      <CardHeader>
        <h2>User Profile</h2>
        <p>Manage your account settings</p>
      </CardHeader>
      <CardContent>
        <UserForm />
      </CardContent>
    </Card>
    ```

  </Tab>
  <Tab value="Props Design">
    ```tsx
    // ‚úÖ Well-designed props interface
    interface ButtonProps {
      // Required props
      children: ReactNode;
      
      // Optional with sensible defaults
      variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
      size?: 'sm' | 'md' | 'lg';
      
      // State props
      disabled?: boolean;
      loading?: boolean;
      
      // Event handlers
      onClick?: (event: MouseEvent<HTMLButtonElement>) => void;
      
      // Styling
      className?: string;
      
      // HTML attributes
      type?: 'button' | 'submit' | 'reset';
    }

    // ‚ùå Poor props design
    interface BadButtonProps {
      text: string; // Should use children instead
      isDisabled: boolean; // Should be optional
      clickHandler: Function; // Should be typed properly
      style: CSSProperties; // Should use className
      color: string; // Should use variant system
    }
    ```

  </Tab>
  <Tab value="State Management">
    ```tsx
    // ‚úÖ Choose appropriate state management
    
    // Local state for component-specific data
    const SearchInput = () => {
      const [query, setQuery] = useState('');
      const [results, setResults] = useState([]);
      
      const debouncedQuery = useDebounce(query, 300);
      
      useEffect(() => {
        if (debouncedQuery) {
          searchApi(debouncedQuery).then(setResults);
        }
      }, [debouncedQuery]);
      
      return (
        <div>
          <input value={query} onChange={(e) => setQuery(e.target.value)} />
          <SearchResults results={results} />
        </div>
      );
    };

    // Context for cross-component state
    const ThemeContext = createContext();

    export const ThemeProvider = ({ children }) => {
      const [theme, setTheme] = useState('light');

      const toggleTheme = useCallback(() => {
        setTheme(prev => prev === 'light' ? 'dark' : 'light');
      }, []);

      const value = useMemo(() => ({
        theme,
        toggleTheme,
      }), [theme, toggleTheme]);

      return (
        <ThemeContext.Provider value={value}>
          {children}
        </ThemeContext.Provider>
      );
    };

    // TanStack Query for server state
    export const useUser = (userId: string) => {
      return useQuery({
        queryKey: ['user', userId],
        queryFn: () => fetchUser(userId),
        staleTime: 5 * 60 * 1000, // 5 minutes
      });
    };
    ```

  </Tab>
</Tabs>

### Custom Hooks Best Practices

```tsx
// ‚úÖ Well-designed custom hook
export const useLocalStorage = <T,>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] => {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function
  const setValue = useCallback(
    (value: T | ((prev: T) => T)) => {
      try {
        // Allow value to be a function so we have the same API as useState
        const valueToStore =
          value instanceof Function ? value(storedValue) : value;

        setStoredValue(valueToStore);

        if (typeof window !== "undefined") {
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
};

// ‚úÖ Data fetching hook with error handling
export const useApi = <T,>(url: string) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const controller = new AbortController();

    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(url, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError(err instanceof Error ? err.message : "An error occurred");
        }
      } finally {
        setLoading(false);
      }
    };

    fetchData();

    return () => {
      controller.abort();
    };
  }, [url]);

  return { data, loading, error };
};
```

## ‚ôø Accessibility Best Practices

### Semantic HTML and ARIA

```tsx
// ‚úÖ Accessible form with proper semantics
const LoginForm = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [errors, setErrors] = useState({});

  return (
    <form onSubmit={handleSubmit} noValidate>
      <fieldset>
        <legend>Login to your account</legend>

        <div className="field">
          <label htmlFor="email">
            Email Address
            <span className="required" aria-label="required">
              *
            </span>
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            aria-describedby={errors.email ? "email-error" : undefined}
            aria-invalid={!!errors.email}
            required
          />
          {errors.email && (
            <div id="email-error" role="alert" className="error">
              {errors.email}
            </div>
          )}
        </div>

        <div className="field">
          <label htmlFor="password">
            Password
            <span className="required" aria-label="required">
              *
            </span>
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            aria-describedby="password-help"
            aria-invalid={!!errors.password}
            required
          />
          <div id="password-help" className="help">
            Must be at least 8 characters long
          </div>
          {errors.password && (
            <div role="alert" className="error">
              {errors.password}
            </div>
          )}
        </div>

        <button type="submit" disabled={loading}>
          {loading ? (
            <>
              <span aria-hidden="true">‚è≥</span>
              <span className="sr-only">Signing in...</span>
              Sign in
            </>
          ) : (
            "Sign in"
          )}
        </button>
      </fieldset>
    </form>
  );
};
```

### Focus Management

```tsx
// ‚úÖ Accessible modal with focus management
const Modal = ({ isOpen, onClose, children, title }) => {
  const modalRef = useRef(null);
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Store current focus
      previousFocusRef.current = document.activeElement;

      // Focus the modal
      modalRef.current?.focus();

      // Prevent body scroll
      document.body.style.overflow = "hidden";
    } else {
      // Restore focus
      previousFocusRef.current?.focus();

      // Restore scroll
      document.body.style.overflow = "unset";
    }

    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  const handleKeyDown = (e) => {
    if (e.key === "Escape") {
      onClose();
    }

    // Trap focus within modal
    if (e.key === "Tab") {
      const focusableElements = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      if (!focusableElements?.length) return;

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (e.shiftKey && document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="modal-backdrop"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        tabIndex={-1}
        className="modal-content"
        onKeyDown={handleKeyDown}
      >
        <div className="modal-header">
          <h2 id="modal-title">{title}</h2>
          <button
            onClick={onClose}
            aria-label="Close modal"
            className="close-button"
          >
            ‚úï
          </button>
        </div>
        <div className="modal-body">{children}</div>
      </div>
    </div>
  );
};
```

### Screen Reader Support

```tsx
// ‚úÖ Accessible data table
const UserTable = ({ users, onSort, sortField, sortDirection }) => {
  return (
    <table role="table" aria-label="User management table">
      <caption className="sr-only">
        List of users with their details and actions. Use tab to navigate
        through the table.
      </caption>

      <thead>
        <tr>
          <th scope="col">
            <button
              onClick={() => onSort("name")}
              aria-sort={
                sortField === "name"
                  ? sortDirection === "asc"
                    ? "ascending"
                    : "descending"
                  : "none"
              }
              className="sort-button"
            >
              Name
              <span aria-hidden="true">
                {sortField === "name" &&
                  (sortDirection === "asc" ? " ‚Üë" : " ‚Üì")}
              </span>
            </button>
          </th>
          <th scope="col">Email</th>
          <th scope="col">Role</th>
          <th scope="col">Actions</th>
        </tr>
      </thead>

      <tbody>
        {users.map((user, index) => (
          <tr key={user.id}>
            <td>{user.name}</td>
            <td>{user.email}</td>
            <td>
              <span
                className={`role-badge role-${user.role.toLowerCase()}`}
                aria-label={`User role: ${user.role}`}
              >
                {user.role}
              </span>
            </td>
            <td>
              <div
                className="action-buttons"
                role="group"
                aria-label="User actions"
              >
                <button
                  onClick={() => onEdit(user)}
                  aria-label={`Edit ${user.name}`}
                >
                  Edit
                </button>
                <button
                  onClick={() => onDelete(user)}
                  aria-label={`Delete ${user.name}`}
                  className="delete-button"
                >
                  Delete
                </button>
              </div>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

## üîí Security Best Practices

### Input Validation and Sanitization

```typescript
import { z } from "zod";
import DOMPurify from "dompurify";

// ‚úÖ Comprehensive input validation
const createUserSchema = z.object({
  email: z
    .string()
    .email("Invalid email format")
    .max(255, "Email too long")
    .transform((email) => email.toLowerCase().trim()),

  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      "Password must contain uppercase, lowercase, number and special character"
    ),

  name: z
    .string()
    .min(2, "Name must be at least 2 characters")
    .max(100, "Name too long")
    .regex(/^[a-zA-Z\s]+$/, "Name can only contain letters and spaces")
    .transform((name) => name.trim()),

  dateOfBirth: z
    .string()
    .datetime()
    .refine((date) => {
      const age = new Date().getFullYear() - new Date(date).getFullYear();
      return age >= 13;
    }, "Must be at least 13 years old"),
});

// ‚úÖ Safe HTML rendering
const SafeHTML = ({ content, allowedTags = ["p", "strong", "em", "a"] }) => {
  const sanitizedContent = useMemo(() => {
    return DOMPurify.sanitize(content, {
      ALLOWED_TAGS: allowedTags,
      ALLOWED_ATTR: ["href", "target"],
      ALLOW_DATA_ATTR: false,
    });
  }, [content, allowedTags]);

  return (
    <div
      dangerouslySetInnerHTML={{ __html: sanitizedContent }}
      className="safe-html-content"
    />
  );
};

// ‚úÖ XSS prevention in user-generated content
const UserComment = ({ comment, author }) => {
  // Never trust user content - always sanitize
  const safeContent = DOMPurify.sanitize(comment.content, {
    ALLOWED_TAGS: ["p", "br", "strong", "em"],
    ALLOWED_ATTR: [],
  });

  return (
    <div className="comment">
      <div className="comment-author">
        {/* Escape user names */}
        {escapeHtml(author.name)}
      </div>
      <div
        className="comment-content"
        dangerouslySetInnerHTML={{ __html: safeContent }}
      />
    </div>
  );
};
```

### Authentication & Authorization

```typescript
// ‚úÖ Secure token handling
const useAuth = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const login = async (credentials) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (!response.ok) {
        throw new Error("Login failed");
      }

      const data = await response.json();

      // Store in httpOnly cookie (server-side)
      // Don't store JWT in localStorage
      setUser(data.user);

      return data;
    } catch (error) {
      console.error("Login error:", error);
      throw error;
    }
  };

  const logout = async () => {
    try {
      await fetch("/api/auth/logout", { method: "POST" });
      setUser(null);
    } catch (error) {
      console.error("Logout error:", error);
      // Still clear user state even if request fails
      setUser(null);
    }
  };

  return { user, loading, login, logout };
};

// ‚úÖ Role-based access control
const ProtectedRoute = ({
  children,
  requiredRole,
  fallback = <AccessDenied />,
}) => {
  const { user, loading } = useAuth();

  if (loading) {
    return <LoadingSpinner />;
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  if (requiredRole && !user.roles.includes(requiredRole)) {
    return fallback;
  }

  return children;
};
```

## üß™ Testing Best Practices

### Component Testing Strategy

```typescript
// ‚úÖ Comprehensive component testing
import { render, screen, waitFor, within } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { rest } from "msw";
import { setupServer } from "msw/node";

// Mock API server for testing
const server = setupServer(
  rest.get("/api/users", (req, res, ctx) => {
    return res(
      ctx.json([
        { id: "1", name: "John Doe", email: "john@example.com" },
        { id: "2", name: "Jane Doe", email: "jane@example.com" },
      ])
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Test wrapper with providers
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>{children}</ThemeProvider>
    </QueryClientProvider>
  );
};

describe("UserList Component", () => {
  describe("Loading State", () => {
    it("displays loading spinner while fetching data", () => {
      render(<UserList />, { wrapper: createWrapper() });
      expect(
        screen.getByRole("status", { name: /loading/i })
      ).toBeInTheDocument();
    });
  });

  describe("Data Display", () => {
    it("displays user list after data loads", async () => {
      render(<UserList />, { wrapper: createWrapper() });

      // Wait for loading to complete
      await waitFor(() => {
        expect(
          screen.queryByRole("status", { name: /loading/i })
        ).not.toBeInTheDocument();
      });

      // Check that users are displayed
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("jane@example.com")).toBeInTheDocument();
    });
  });

  describe("User Interactions", () => {
    it("opens user details when user is clicked", async () => {
      const user = userEvent.setup();
      render(<UserList />, { wrapper: createWrapper() });

      await waitFor(() => {
        expect(screen.getByText("John Doe")).toBeInTheDocument();
      });

      await user.click(screen.getByText("John Doe"));

      expect(
        screen.getByRole("dialog", { name: /user details/i })
      ).toBeInTheDocument();
    });
  });

  describe("Error Handling", () => {
    it("displays error message when API fails", async () => {
      server.use(
        rest.get("/api/users", (req, res, ctx) => {
          return res(ctx.status(500), ctx.json({ message: "Server error" }));
        })
      );

      render(<UserList />, { wrapper: createWrapper() });

      await waitFor(() => {
        expect(screen.getByRole("alert")).toBeInTheDocument();
        expect(screen.getByText(/failed to load users/i)).toBeInTheDocument();
      });
    });
  });

  describe("Accessibility", () => {
    it("has proper ARIA labels and roles", async () => {
      render(<UserList />, { wrapper: createWrapper() });

      await waitFor(() => {
        const list = screen.getByRole("list", { name: /users/i });
        expect(list).toBeInTheDocument();

        const listItems = within(list).getAllByRole("listitem");
        expect(listItems).toHaveLength(2);
      });
    });

    it("supports keyboard navigation", async () => {
      const user = userEvent.setup();
      render(<UserList />, { wrapper: createWrapper() });

      await waitFor(() => {
        expect(screen.getByText("John Doe")).toBeInTheDocument();
      });

      // Tab to first user
      await user.tab();
      expect(screen.getByText("John Doe")).toHaveFocus();

      // Enter to open details
      await user.keyboard("{Enter}");
      expect(screen.getByRole("dialog")).toBeInTheDocument();
    });
  });
});
```

## üìä Monitoring & Analytics

### Performance Monitoring

```typescript
// ‚úÖ Core Web Vitals monitoring
import { getCLS, getFID, getFCP, getLCP, getTTFB } from "web-vitals";

const sendToAnalytics = (metric) => {
  // Send to your analytics service
  gtag("event", metric.name, {
    event_category: "Web Vitals",
    value: Math.round(metric.value),
    event_label: metric.id,
  });
};

// Monitor all Core Web Vitals
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);

// ‚úÖ Custom performance monitoring
const usePerformanceMonitor = () => {
  useEffect(() => {
    // Monitor component mount time
    const startTime = performance.now();

    return () => {
      const mountTime = performance.now() - startTime;
      if (mountTime > 100) {
        // Alert if component takes too long
        console.warn(`Component took ${mountTime}ms to mount`);
      }
    };
  }, []);
};

// ‚úÖ Error boundary with monitoring
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to monitoring service
    console.error("Error boundary caught an error:", error, errorInfo);

    // Send to error reporting service
    if (typeof window !== "undefined") {
      // Example: Sentry.captureException(error, { extra: errorInfo });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div role="alert" className="error-boundary">
            <h2>Something went wrong.</h2>
            <details>
              <summary>Error details</summary>
              <p>
                Please refresh the page or contact support if the problem
                persists.
              </p>
            </details>
          </div>
        )
      );
    }

    return this.props.children;
  }
}
```

<Callout type="tip">
  These best practices are continuously evolving. Stay updated with the latest
  React and Next.js patterns, and always measure the impact of optimizations in
  your specific use case.
</Callout>

## üéØ Quality Checklist

Use this checklist to ensure your code meets our best practices:

### Performance ‚úÖ

- [ ] Images optimized with Next.js Image component
- [ ] Code splitting implemented for large components
- [ ] Memoization used appropriately (not overused)
- [ ] Bundle size impact measured and acceptable
- [ ] Core Web Vitals targets met in production

### Accessibility ‚úÖ

- [ ] Semantic HTML used throughout
- [ ] ARIA labels provided where needed
- [ ] Keyboard navigation works correctly
- [ ] Color contrast meets WCAG AA standards
- [ ] Screen reader testing completed

### Security ‚úÖ

- [ ] All user inputs validated and sanitized
- [ ] No sensitive data exposed in client code
- [ ] Authentication properly implemented
- [ ] XSS protection in place for user content
- [ ] Dependencies regularly updated and audited

### Code Quality ‚úÖ

- [ ] Components follow single responsibility principle
- [ ] Error boundaries implemented for error handling
- [ ] Loading and error states properly handled
- [ ] Tests cover critical functionality (>80% coverage)
- [ ] Code is documented and self-explanatory

### Team Standards ‚úÖ

- [ ] Naming conventions followed consistently
- [ ] Code formatted with Prettier
- [ ] ESLint rules passing without warnings
- [ ] TypeScript types are specific (no `any`)
- [ ] Pull request properly reviewed and approved
