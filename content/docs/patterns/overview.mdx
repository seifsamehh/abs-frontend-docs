---
title: Development Patterns
description: Common patterns and architectural decisions for frontend development
---

import { Card, Cards } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

# üé® Development Patterns

<Callout type="info">
  This section covers common patterns and architectural decisions we use in our
  frontend applications. These patterns help maintain consistency, improve
  maintainability, and solve common problems effectively.
</Callout>

## üèóÔ∏è Pattern Categories

<Cards>
  <Card
    title="üè™ State Management"
    href="/docs/patterns/state-management"
    description="Redux, Context API, and state management patterns"
  />
  <Card
    title="üì° Data Fetching"
    href="/docs/patterns/data-fetching"
    description="API calls, caching, and data synchronization"
  />
  <Card
    title="‚ö†Ô∏è Error Handling"
    href="/docs/patterns/error-handling"
    description="Error boundaries, error states, and recovery patterns"
  />
  <Card
    title="üß≠ Routing"
    href="/docs/patterns/routing"
    description="Navigation, route guards, and routing patterns"
  />
</Cards>

<Cards>
  <Card
    title="üìù Forms"
    href="/docs/patterns/forms"
    description="Form validation, submission, and user input patterns"
  />
  <Card
    title="üîê Authentication"
    href="/docs/patterns/authentication"
    description="Login, authorization, and security patterns"
  />
  <Card
    title="üé≠ UI Patterns"
    href="/docs/patterns/ui-patterns"
    description="Loading states, empty states, and UI feedback"
  />
  <Card
    title="üì± Mobile Patterns"
    href="/docs/patterns/mobile"
    description="Touch interactions and mobile-specific patterns"
  />
</Cards>

## üéØ Core Principles

### 1. **Composition over Inheritance**

Build complex functionality by combining simple, focused components:

```tsx
// Good: Composition
function UserProfile({ user }: { user: User }) {
  return (
    <Card>
      <CardHeader>
        <UserAvatar user={user} />
        <UserName user={user} />
      </CardHeader>
      <CardContent>
        <UserDetails user={user} />
        <UserActions user={user} />
      </CardContent>
    </Card>
  );
}

// Avoid: Inheritance
class UserProfile extends BaseProfile {
  // Complex inheritance hierarchy
}
```

### 2. **Single Responsibility Principle**

Each component, hook, or function should have one clear purpose:

```tsx
// Good: Single responsibility
function useUserData(userId: string) {
  return useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId),
  });
}

function useUserPermissions(userId: string) {
  return useQuery({
    queryKey: ["user-permissions", userId],
    queryFn: () => fetchUserPermissions(userId),
  });
}

// Avoid: Multiple responsibilities
function useUserEverything(userId: string) {
  // Handles data, permissions, preferences, etc.
}
```

### 3. **Separation of Concerns**

Keep UI, business logic, and data fetching separate:

```tsx
// Good: Separated concerns
function UserList() {
  const { data: users, isLoading } = useUsers();
  const { handleDeleteUser } = useUserActions();

  if (isLoading) return <UserListSkeleton />;

  return (
    <div>
      {users?.map((user) => (
        <UserCard key={user.id} user={user} onDelete={handleDeleteUser} />
      ))}
    </div>
  );
}

// Business logic in custom hook
function useUserActions() {
  const queryClient = useQueryClient();

  const handleDeleteUser = useMutation({
    mutationFn: deleteUser,
    onSuccess: () => {
      queryClient.invalidateQueries(["users"]);
    },
  });

  return { handleDeleteUser };
}
```

## üè™ State Management Patterns

### Local State

Use React's built-in state for component-specific data:

```tsx
function SearchInput() {
  const [query, setQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);

  const handleSearch = useCallback(async (searchQuery: string) => {
    setIsSearching(true);
    try {
      await performSearch(searchQuery);
    } finally {
      setIsSearching(false);
    }
  }, []);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      {isSearching && <Spinner />}
    </div>
  );
}
```

### Context for App-Wide State

Use Context API for theme, user data, or app-wide settings:

```tsx
interface ThemeContextValue {
  theme: "light" | "dark";
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<"light" | "dark">("light");

  const toggleTheme = useCallback(() => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  }, []);

  const value = useMemo(
    () => ({
      theme,
      toggleTheme,
    }),
    [theme, toggleTheme]
  );

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
```

### Redux for Complex State

Use Redux Toolkit for complex state management:

```tsx
// Store slice
const userSlice = createSlice({
  name: "user",
  initialState: {
    currentUser: null,
    isLoading: false,
    error: null,
  },
  reducers: {
    setUser: (state, action) => {
      state.currentUser = action.payload;
    },
    setLoading: (state, action) => {
      state.isLoading = action.payload;
    },
    setError: (state, action) => {
      state.error = action.payload;
    },
  },
});

// Component usage
function UserProfile() {
  const dispatch = useDispatch();
  const { currentUser, isLoading } = useSelector((state) => state.user);

  useEffect(() => {
    dispatch(fetchUser());
  }, [dispatch]);

  if (isLoading) return <LoadingSpinner />;
  if (!currentUser) return <LoginPrompt />;

  return <UserDetails user={currentUser} />;
}
```

## üì° Data Fetching Patterns

### React Query for Server State

Use TanStack Query for server state management:

```tsx
// Query hooks
export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useUser(userId: string) {
  return useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId),
    enabled: !!userId,
  });
}

// Mutation hooks
export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createUser,
    onSuccess: (newUser) => {
      queryClient.setQueryData(["users"], (old: User[] = []) => [
        ...old,
        newUser,
      ]);
    },
  });
}

// Component usage
function UserList() {
  const { data: users, isLoading, error } = useUsers();
  const createUser = useCreateUser();

  const handleCreateUser = (userData: CreateUserData) => {
    createUser.mutate(userData);
  };

  if (isLoading) return <UserListSkeleton />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      <CreateUserForm onSubmit={handleCreateUser} />
      {users?.map((user) => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### Optimistic Updates

Implement optimistic updates for better UX:

```tsx
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateUser,
    onMutate: async (newUser) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries(["user", newUser.id]);

      // Snapshot previous value
      const previousUser = queryClient.getQueryData(["user", newUser.id]);

      // Optimistically update
      queryClient.setQueryData(["user", newUser.id], newUser);

      return { previousUser };
    },
    onError: (err, newUser, context) => {
      // Rollback on error
      queryClient.setQueryData(["user", newUser.id], context?.previousUser);
    },
    onSettled: (data, error, variables) => {
      // Refetch after mutation
      queryClient.invalidateQueries(["user", variables.id]);
    },
  });
}
```

## ‚ö†Ô∏è Error Handling Patterns

### Error Boundaries

Use error boundaries to catch and handle errors gracefully:

```tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<
  { children: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }

    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <UserProfile />
    </ErrorBoundary>
  );
}
```

### Result Pattern

Use Result pattern for predictable error handling:

```tsx
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await apiClient.get<User>(`/users/${id}`);
    return { success: true, data: user };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error("Unknown error"),
    };
  }
}

// Usage in component
function UserProfile({ userId }: { userId: string }) {
  const [result, setResult] = useState<Result<User> | null>(null);

  useEffect(() => {
    fetchUser(userId).then(setResult);
  }, [userId]);

  if (!result) return <LoadingSpinner />;
  if (!result.success) return <ErrorMessage error={result.error} />;

  return <UserDetails user={result.data} />;
}
```

## üß≠ Routing Patterns

### Route Guards

Implement authentication and authorization guards:

```tsx
function ProtectedRoute({ children }: { children: ReactNode }) {
  const { user, isLoading } = useAuth();

  if (isLoading) return <LoadingSpinner />;
  if (!user) return <Navigate to="/login" replace />;

  return <>{children}</>;
}

// Usage
function App() {
  return (
    <Router>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <DashboardPage />
            </ProtectedRoute>
          }
        />
      </Routes>
    </Router>
  );
}
```

### Lazy Loading

Implement code splitting for better performance:

```tsx
const Dashboard = lazy(() => import("./Dashboard"));
const Settings = lazy(() => import("./Settings"));
const Profile = lazy(() => import("./Profile"));

function App() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/settings" element={<Settings />} />
        <Route path="/profile" element={<Profile />} />
      </Routes>
    </Suspense>
  );
}
```

## üìù Form Patterns

### Controlled Components

Use controlled components for form state:

```tsx
function ContactForm() {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleChange =
    (field: string) => (e: ChangeEvent<HTMLInputElement>) => {
      setFormData((prev) => ({
        ...prev,
        [field]: e.target.value,
      }));

      // Clear error when user starts typing
      if (errors[field]) {
        setErrors((prev) => ({
          ...prev,
          [field]: "",
        }));
      }
    };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    const validationErrors = validateForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      await submitForm(formData);
      // Handle success
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={formData.name}
        onChange={handleChange("name")}
        error={errors.name}
        placeholder="Your name"
      />
      <Input
        value={formData.email}
        onChange={handleChange("email")}
        error={errors.email}
        placeholder="Your email"
      />
      <Textarea
        value={formData.message}
        onChange={handleChange("message")}
        error={errors.message}
        placeholder="Your message"
      />
      <Button type="submit">Send Message</Button>
    </form>
  );
}
```

### Form Libraries Integration

Integrate with form libraries like React Hook Form:

```tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const schema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(10, "Message must be at least 10 characters"),
});

type FormData = z.infer<typeof schema>;

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  });

  const onSubmit = async (data: FormData) => {
    try {
      await submitForm(data);
      // Handle success
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Input
        {...register("name")}
        error={errors.name?.message}
        placeholder="Your name"
      />
      <Input
        {...register("email")}
        error={errors.email?.message}
        placeholder="Your email"
      />
      <Textarea
        {...register("message")}
        error={errors.message?.message}
        placeholder="Your message"
      />
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Sending..." : "Send Message"}
      </Button>
    </form>
  );
}
```

## üéØ Best Practices

<Callout type="tip">
  Follow these best practices when implementing patterns:
</Callout>

1. **Choose the Right Pattern** - Match the pattern to the problem complexity
2. **Keep It Simple** - Start with simple patterns and evolve as needed
3. **Be Consistent** - Use the same patterns across similar features
4. **Document Patterns** - Explain why and when to use each pattern
5. **Test Patterns** - Ensure patterns work correctly in all scenarios
6. **Refactor Regularly** - Update patterns as requirements change
7. **Share Knowledge** - Help team members understand and adopt patterns

## üîÑ Pattern Evolution

### When to Refactor Patterns

- **Performance Issues** - Pattern causes performance problems
- **Maintenance Burden** - Pattern becomes hard to maintain
- **New Requirements** - Pattern doesn't support new features
- **Team Feedback** - Pattern causes confusion or errors
- **Technology Changes** - New tools or libraries available

### Pattern Documentation

- **Problem Statement** - What problem does the pattern solve?
- **Solution** - How does the pattern work?
- **When to Use** - Under what circumstances?
- **Examples** - Code examples and real-world usage
- **Trade-offs** - Benefits and limitations
- **Alternatives** - Other patterns that could be used

<Callout type="note">
  Patterns should evolve with your team and technology stack. Regular review and
  updates ensure they remain relevant and useful.
</Callout>
